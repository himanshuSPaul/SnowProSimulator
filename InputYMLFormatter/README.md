# standardize_kb.py

> **SnowPro Exam Knowledge Base — YAML Standardisation Tool**

Converts any loosely-formatted SnowPro Q&A YAML file into a single, consistent
canonical schema so that all knowledge-base files across topics and sub-topics
look and behave identically — regardless of how they were originally authored.

---

## Table of Contents

1. [What Does It Do?](#1-what-does-it-do)
2. [Prerequisites](#2-prerequisites)
3. [Usage](#3-usage)
4. [Output File Structure](#4-output-file-structure)
5. [Source → Target Key Mapping](#5-source--target-key-mapping)
   - 5.1 [Top-Level / Header Fields](#51-top-level--header-fields)
   - 5.2 [Per-Question Fields](#52-per-question-fields)
   - 5.3 [Option Key Variants](#53-option-key-variants)
   - 5.4 [Answer Value Variants](#54-answer-value-variants)
   - 5.5 [Difficulty Value Normalisation](#55-difficulty-value-normalisation)
   - 5.6 [Exam Tag Normalisation](#56-exam-tag-normalisation)
6. [Normalisation Rules — Detail](#6-normalisation-rules--detail)
7. [Validation & Error Reporting](#7-validation--error-reporting)
8. [Processing Pipeline](#8-processing-pipeline)
9. [File Naming Convention](#9-file-naming-convention)
10. [Example: Before & After](#10-example-before--after)
11. [Extending the Script](#11-extending-the-script)

---

## 1. What Does It Do?

Knowledge-base YAML files for SnowPro exam preparation are generated by LLMs
or authored manually. Over time, field names drift — some files use `options`,
others use `their options` or `their_options`; some write `correct answer`
while others write `Answer` or `correct_answer`. This makes downstream tooling
(quiz engines, flash-card generators, CI validators) brittle.

`standardize_kb.py` solves this by:

| Step | Description |
|------|-------------|
| **Parse** | Loads any valid YAML file using `yaml.safe_load` |
| **Resolve** | Finds each field using a priority list of known key variants (case-insensitive) |
| **Normalise** | Converts values (difficulty, exam tags, option keys, answer format, question number) to canonical forms |
| **Validate** | Reports any questions with missing required fields |
| **Emit** | Writes a clean, consistently formatted YAML file |

The script does **not** modify the semantic content of any field — only the
structure and key names.

---

## 2. Prerequisites

| Requirement | Version |
|-------------|---------|
| Python | 3.8 + |
| PyYAML | any recent version (`pip install pyyaml`) |

Install dependencies:

```bash
pip install pyyaml
```

---

## 3. Usage

```bash
# Auto-generate output filename  →  <input>_standardized.yml
python standardize_kb.py <input_file.yml>

# Specify output path explicitly
python standardize_kb.py <input_file.yml> <output_file.yml>
```

**Examples:**

```bash
# Single file
python standardize_kb.py snowflake_kb_virtual_warehouses.yml

# Custom output location
python standardize_kb.py raw/caching_kb.yml clean/caching_kb_v2.yml

# Batch — bash loop over a folder
for f in raw/*.yml; do
    python standardize_kb.py "$f" "clean/$(basename $f)"
done
```

**Console output:**

```
Loading   : snowflake_kb_virtual_warehouses.yml
Standardizing ...
✓ Validation passed – no issues found.

✓ Standardized file saved to: snowflake_kb_virtual_warehouses_standardized.yml
  Topic    : Virtual Warehouses
  Sub-Topic: Warehouse Fundamentals, Warehouse Sizing, Warehouse Scaling
  Questions: 20
```

---

## 4. Output File Structure

Every standardised file has the following top-level layout:

```yaml
Topic Name: "Virtual Warehouses"
Sub Topic Name: "Warehouse Fundamentals, Warehouse Sizing, Warehouse Scaling"
Total Question Count: 20

all questions:

  - Question No: "001"
    question: "What is a Snowflake Virtual Warehouse?"
    their_options:
      option A: "A physical server cluster managed by Snowflake"
      option B: "A named abstraction for a cluster of compute resources..."
      option C: "A storage layer that holds structured data"
      option D: "A database object that stores virtual tables"
      option E: "A cloud provider-specific VM instance group"
    correct Answer: "option B"
    explanation: >
      Detailed explanation of why option B is correct and why A, C, D, E
      are wrong...
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Fundamentals"
    exam: "Core, DataEngineer, Architect"
```

### Field Definitions

| Field | Type | Description |
|-------|------|-------------|
| `Topic Name` | string | The parent topic (e.g. `Virtual Warehouses`) |
| `Sub Topic Name` | string | Comma-separated sub-topics covered in this file |
| `Total Question Count` | integer | Auto-calculated count of all questions in the file |
| `all questions` | list | Ordered list of question objects |

### Per-Question Field Definitions

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `Question No` | quoted string | Zero-padded to 3 digits, e.g. `"001"` | Unique sequential identifier |
| `question` | string | Required | Full question text |
| `their_options` | mapping | Keys: `option A` … `option E` | Answer choices (3–5 options) |
| `correct Answer` | string | `option A` … `option E`, or comma-separated for multi-answer | The correct choice(s) |
| `explanation` | block scalar (`>`) | Required | Detailed explanation covering why the answer is right and why wrong options are wrong |
| `difficulty level` | string | `Easy` \| `Medium` \| `Hard` | Question difficulty |
| `topic` | string | | Parent topic (mirrors `Topic Name`) |
| `sub topic` | string | | Sub-topic this question belongs to |
| `exam` | string | Comma-separated subset of: `Core`, `DataEngineer`, `DataAnalyst`, `Architect` | Relevant exam tracks |

---

## 5. Source → Target Key Mapping

### 5.1 Top-Level / Header Fields

| Any of these source keys (case-insensitive) | → | Canonical output key |
|---------------------------------------------|---|----------------------|
| `Topic Name`, `topic name`, `Topic`, `topic` | → | `Topic Name` |
| `Sub Topic Name`, `sub topic name`, `Sub Topic`, `subtopic`, `sub_topic` | → | `Sub Topic Name` |
| `Total Question Count`, `total question count`, `total_questions`, `question_count` | → | `Total Question Count` *(auto-recalculated)* |
| `all questions`, `all_questions`, `questions`, `Questions` | → | `all questions` |

---

### 5.2 Per-Question Fields

| Any of these source keys (case-insensitive) | → | Canonical output key |
|---------------------------------------------|---|----------------------|
| `Question No`, `question no`, `question_no`, `Q No`, `id` | → | `Question No` |
| `question`, `Question`, `q`, `Q` | → | `question` |
| `their_options`, `their options`, `options`, `Options` | → | `their_options` |
| `correct Answer`, `correct answer`, `correct_answer`, `answer`, `Answer` | → | `correct Answer` |
| `explanation`, `Explanation` | → | `explanation` |
| `difficulty level`, `difficulty_level`, `difficulty`, `Difficulty` | → | `difficulty level` |
| `topic`, `Topic` | → | `topic` |
| `sub topic`, `sub_topic`, `subtopic`, `Sub Topic` | → | `sub topic` |
| `exam`, `Exam`, `exams`, `Exams` | → | `exam` |

---

### 5.3 Option Key Variants

The options block (`their_options`) can arrive in many key styles. All are
normalised to `option A` … `option E`.

| Source key style | Normalises to |
|-----------------|---------------|
| `option A` | `option A` |
| `option a` | `option A` |
| `optionA` | `option A` |
| `OptionA` | `option A` |
| `A` | `option A` |
| `a` | `option A` |
| *(same pattern for B, C, D, E)* | `option B` … `option E` |
| Plain list `["text1", "text2", ...]` | `option A`, `option B`, … in order |

> Options beyond `option E` (i.e. F+) are silently discarded. Questions may
> have fewer than 5 options — only present options are emitted.

---

### 5.4 Answer Value Variants

The `correct Answer` field is normalised to the canonical `option X` format.

| Source value | Normalises to |
|-------------|---------------|
| `option B` | `option B` |
| `option b` | `option B` |
| `optionB` | `option B` |
| `B` | `option B` |
| `b` | `option B` |
| `"B, D"` *(multi-answer string)* | `option B, option D` |
| `["B", "D"]` *(multi-answer list)* | `option B, option D` |
| `["option B", "option D"]` | `option B, option D` |

---

### 5.5 Difficulty Value Normalisation

| Source value (any casing) | Normalises to |
|--------------------------|---------------|
| `easy`, `Easy`, `EASY`, `eas…` *(prefix match)* | `Easy` |
| `medium`, `Medium`, `MEDIUM`, `med…` | `Medium` |
| `hard`, `Hard`, `HARD`, `har…` | `Hard` |
| *(missing / unrecognised)* | `Medium` *(default fallback)* |

---

### 5.6 Exam Tag Normalisation

Exam tags are matched case-insensitively. Unrecognised tags are silently dropped.
If the result is empty, `Core` is used as the default fallback.

| Source value(s) | Normalises to |
|----------------|---------------|
| `"Core, DataEngineer"` | `Core, DataEngineer` |
| `"core,dataengineer,architect"` | `Core, DataEngineer, Architect` |
| `["Core", "dataanalyst"]` | `Core, DataAnalyst` |
| `"CORE"` | `Core` |
| `"DataEng"` *(unrecognised)* | *(dropped — fallback to `Core`)* |
| *(missing)* | `Core` |

Valid exam tags: `Core` · `DataEngineer` · `DataAnalyst` · `Architect`

---

## 6. Normalisation Rules — Detail

### Question Number (`Question No`)
- Strips surrounding whitespace and leading zeros before re-padding.
- Always zero-padded to 3 digits: `1` → `"001"`, `42` → `"042"`.
- Non-numeric values (e.g. `"Q1"`) are kept as-is after stripping.
- If the field is entirely missing, the 1-based index position is used.

### Explanation (`explanation`)
- Written as a YAML **block scalar** (`>` style) for readability.
- Whitespace is preserved; no content modification is made.

### Total Question Count
- Always **auto-recalculated** from the actual number of questions parsed,
  overriding whatever value was in the source file.

### YAML Formatting
- Block style throughout (no inline/flow dicts).
- 2-space indentation.
- UTF-8 encoding with `allow_unicode=True`.
- Key order is preserved (insertion order, `sort_keys=False`).
- Line width: 120 characters.

---

## 7. Validation & Error Reporting

After standardisation, every question is checked for:

| Check | Condition flagged |
|-------|------------------|
| Missing question text | `question` field is empty |
| Missing options | `their_options` dict is empty |
| Missing answer | `correct Answer` field is empty |
| Invalid difficulty | Value is not `Easy`, `Medium`, or `Hard` |

Validation results are printed to the console. The output file is **always
written** even if issues are found, so you can inspect and fix manually.

```
⚠  2 validation issue(s) found:
   • Q"003": missing correct answer
   • Q"007": no options found
```

---

## 8. Processing Pipeline

```
Input YAML file
      │
      ▼
 yaml.safe_load()
      │
      ▼
┌─────────────────────────────┐
│  Top-level key resolution   │  ← case-insensitive lookup from known variants
│  (Topic, Sub-topic, etc.)   │
└─────────────┬───────────────┘
              │
              ▼
┌─────────────────────────────┐
│  Per-question normalisation │
│  ┌─────────────────────┐    │
│  │ Resolve field keys  │    │  ← pick first matching key variant
│  │ Normalise Q No      │    │  ← zero-pad to 3 digits
│  │ Normalise options   │    │  ← dict or list → option A…E
│  │ Normalise answer    │    │  ← letter/string/list → option X
│  │ Normalise difficulty│    │  ← prefix match → Easy/Medium/Hard
│  │ Normalise exam tags │    │  ← case fold → canonical CSV
│  └─────────────────────┘    │
└─────────────┬───────────────┘
              │
              ▼
       Validation check
              │
              ▼
   yaml.dump() → output file
```

---

## 9. File Naming Convention

| Scenario | Output filename |
|----------|----------------|
| No output argument given | `<input_stem>_standardized.yml` in same directory |
| Output argument provided | Exactly as specified |

**Example:**

```
Input : raw/snowflake_kb_virtual_warehouses.yml
Output: raw/snowflake_kb_virtual_warehouses_standardized.yml
```

---

## 10. Example: Before & After

### Input (messy / varied format)

```yaml
topic: Virtual Warehouses
subtopic: Caching
question_count: 1
questions:
  - id: 1
    Question: "What layer stores the Query Result Cache?"
    options:
      optionA: "Virtual Warehouse compute layer"
      optionB: "Cloud Services layer"
      optionC: "Storage layer"
      optionD: "Client driver cache"
    answer: B
    Explanation: "The Query Result Cache lives in the Cloud Services layer..."
    difficulty: hard
    Exam: [core, dataengineer]
```

### Output (standardised)

```yaml
Topic Name: Virtual Warehouses
Sub Topic Name: Caching
Total Question Count: 1

all questions:
  - Question No: "001"
    question: What layer stores the Query Result Cache?
    their_options:
      option A: Virtual Warehouse compute layer
      option B: Cloud Services layer
      option C: Storage layer
      option D: Client driver cache
    correct Answer: option B
    explanation: >
      The Query Result Cache lives in the Cloud Services layer...
    difficulty level: Hard
    topic: Virtual Warehouses
    sub topic: Caching
    exam: Core, DataEngineer
```

---

## 11. Extending the Script

### Adding new key aliases

Open the script and locate the key-lists section. Append your new variant:

```python
# Example: support "quiz_topic" as an alias for topic
Q_TOPIC_KEYS = ["topic", "Topic", "quiz_topic"]
```

### Adding a new valid exam tag

Add it to the set:

```python
VALID_EXAMS = {"Core", "DataEngineer", "DataAnalyst", "Architect", "DataScientist"}
```

### Adding new difficulty levels

```python
VALID_DIFFICULTIES = {"Easy", "Medium", "Hard", "Expert"}
```

### Batch processing wrapper

```python
from pathlib import Path
import subprocess

for yml in Path("raw").glob("*.yml"):
    subprocess.run(["python", "standardize_kb.py", str(yml), f"clean/{yml.name}"])
```

---

*Script authored for SnowPro exam preparation tooling.
Canonical schema version: **1.0***.
