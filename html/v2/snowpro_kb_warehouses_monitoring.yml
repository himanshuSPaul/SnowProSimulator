Topic Name: "Virtual Warehouses"
Sub Topic Name: "Warehouse Monitoring"
Total Question Count: 500
all questions:

  - Question No: "001"
    question: "What is the primary purpose of the Snowflake WAREHOUSE_METERING_HISTORY view?"
    their_options:
      option A: "To track query execution plans"
      option B: "To monitor credit consumption by virtual warehouses over time"
      option C: "To view the DDL of all warehouses"
      option D: "To list all users who have accessed a warehouse"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_METERING_HISTORY provides information about credit usage
      by virtual warehouses, including credits consumed per hour/day. A is wrong because query
      execution plans are found in QUERY_PROFILE. C is wrong because DDL information is accessed
      via GET_DDL or SHOW WAREHOUSES. D is wrong because user access is tracked in ACCESS_HISTORY
      or LOGIN_HISTORY views.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "002"
    question: "Which Snowflake schema contains the WAREHOUSE_METERING_HISTORY view?"
    their_options:
      option A: "INFORMATION_SCHEMA"
      option B: "ACCOUNT_USAGE"
      option C: "Both INFORMATION_SCHEMA and ACCOUNT_USAGE"
      option D: "ORGANIZATION_USAGE"
    correct Answer: "C"
    explanation: >
      C is correct because the WAREHOUSE_METERING_HISTORY view exists in both the
      INFORMATION_SCHEMA (with a 14-day lookback) and the ACCOUNT_USAGE schema in the
      SNOWFLAKE database (with up to 365-day lookback). A and B are each only partially
      correct. D is wrong because ORGANIZATION_USAGE contains organization-level views,
      not warehouse-level metering.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "003"
    question: "What is the data retention period for WAREHOUSE_METERING_HISTORY in the ACCOUNT_USAGE schema?"
    their_options:
      option A: "14 days"
      option B: "30 days"
      option C: "180 days"
      option D: "365 days"
    correct Answer: "D"
    explanation: >
      D is correct because the ACCOUNT_USAGE schema retains data for up to 365 days (1 year).
      A is wrong because 14 days is the retention for the INFORMATION_SCHEMA version. B and C
      are incorrect retention periods that do not apply to ACCOUNT_USAGE views.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst, Architect

  - Question No: "004"
    question: "What is the data retention period for WAREHOUSE_METERING_HISTORY in INFORMATION_SCHEMA?"
    their_options:
      option A: "7 days"
      option B: "14 days"
      option C: "30 days"
      option D: "365 days"
    correct Answer: "B"
    explanation: >
      B is correct because the INFORMATION_SCHEMA version of WAREHOUSE_METERING_HISTORY
      retains data for 14 days. A is wrong (7 days does not apply here). C (30 days) and
      D (365 days) are incorrect; 365 days applies to the ACCOUNT_USAGE schema version.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "005"
    question: "Which SQL command allows you to view the current state and properties of a virtual warehouse?"
    their_options:
      option A: "DESCRIBE WAREHOUSE"
      option B: "SHOW WAREHOUSES"
      option C: "LIST WAREHOUSES"
      option D: "GET WAREHOUSE"
    correct Answer: "B"
    explanation: >
      B is correct because SHOW WAREHOUSES lists all warehouses the current role has access
      to, displaying properties like size, state, auto_suspend, etc. A is wrong because
      DESCRIBE WAREHOUSE is not a valid Snowflake command. C and D are not valid Snowflake
      SQL commands for viewing warehouse details.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst, Architect

  - Question No: "006"
    question: "A company notices unexpected credit consumption spikes every night at 2 AM. Which view should they query FIRST to identify which warehouse is consuming credits?"
    their_options:
      option A: "QUERY_HISTORY"
      option B: "WAREHOUSE_METERING_HISTORY"
      option C: "WAREHOUSE_LOAD_HISTORY"
      option D: "LOGIN_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_METERING_HISTORY provides credit consumption broken
      down by warehouse and time interval, making it the best first step to identify which
      warehouse is causing the spike. A (QUERY_HISTORY) could help later to find specific
      queries but is not the first step for credit attribution. C (WAREHOUSE_LOAD_HISTORY)
      shows load metrics but not credit consumption directly. D (LOGIN_HISTORY) shows login
      events, not credit usage.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "007"
    question: "What does the WAREHOUSE_LOAD_HISTORY view measure?"
    their_options:
      option A: "Credit consumption per warehouse"
      option B: "Data loading throughput for COPY INTO commands"
      option C: "The average and peak query load on a warehouse over time"
      option D: "The number of concurrent users on a warehouse"
    correct Answer: "C"
    explanation: >
      C is correct because WAREHOUSE_LOAD_HISTORY provides data about the average and peak
      running and queued query loads for a warehouse over time intervals. A is wrong because
      credit consumption is tracked in WAREHOUSE_METERING_HISTORY. B is wrong because data
      loading throughput is tracked via COPY_HISTORY. D is wrong because concurrent users
      are not directly measured by this view.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "008"
    question: "Which TWO metrics are available in the WAREHOUSE_LOAD_HISTORY view? (Select TWO)"
    their_options:
      option A: "AVG_RUNNING"
      option B: "CREDITS_USED"
      option C: "AVG_QUEUED_LOAD"
      option D: "BYTES_SCANNED"
      option E: "AVG_BLOCKED"
    correct Answer: "A, C"
    explanation: >
      A and C are correct. WAREHOUSE_LOAD_HISTORY includes AVG_RUNNING (average number of
      queries executing) and AVG_QUEUED_LOAD (average number of queries queued because the
      warehouse was fully loaded). B is wrong because CREDITS_USED belongs to
      WAREHOUSE_METERING_HISTORY. D is wrong because BYTES_SCANNED is a QUERY_HISTORY metric.
      E is wrong because AVG_BLOCKED is in WAREHOUSE_LOAD_HISTORY but represents queries
      blocked by transactions, and the question asks for the two primary load metrics.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "009"
    question: "In Snowsight, where can you find the warehouse activity monitoring dashboard?"
    their_options:
      option A: "Admin > Warehouses"
      option B: "Activity > Warehouses"
      option C: "Monitoring > Warehouses"
      option D: "Data > Warehouses"
    correct Answer: "A"
    explanation: >
      A is correct because in Snowsight, the warehouse monitoring page is found under
      Admin > Warehouses, where you can see warehouse status, size, credit usage, and
      activity. B is wrong because the Activity section shows query activity, not warehouse
      configuration and monitoring. C is wrong because there is no separate Monitoring
      section in Snowsight. D is wrong because Data section is for databases and schemas.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst

  - Question No: "010"
    question: "What does the 'state' column in SHOW WAREHOUSES indicate?"
    their_options:
      option A: "Whether the warehouse is Enterprise or Standard edition"
      option B: "The current operational state: Started, Suspended, or Resizing"
      option C: "The geographic region of the warehouse"
      option D: "The tier of the warehouse (economy, standard, premium)"
    correct Answer: "B"
    explanation: >
      B is correct because the state column shows the current operational status of the
      warehouse such as Started (running), Suspended (not running), or Resizing. A is wrong
      because edition info is account-level, not warehouse-level. C is wrong because region
      is an account property. D is wrong because Snowflake warehouses do not have tiers.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "011"
    question: "A data engineer notices that the AVG_QUEUED_LOAD value in WAREHOUSE_LOAD_HISTORY is consistently above 1 during business hours. What does this indicate?"
    their_options:
      option A: "The warehouse is idle and should be downsized"
      option B: "Queries are being queued because the warehouse does not have enough resources"
      option C: "The warehouse has failed and needs to be restarted"
      option D: "The queries are running optimally with no issues"
    correct Answer: "B"
    explanation: >
      B is correct because AVG_QUEUED_LOAD > 0 indicates that queries are waiting in the
      queue because the warehouse is fully loaded, meaning it lacks enough compute resources
      for the demand. A is wrong because idle warehouses would show AVG_RUNNING near 0.
      C is wrong because warehouse failure would not manifest as queued queries. D is wrong
      because queued queries indicate sub-optimal performance, not optimal execution.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "012"
    question: "Which role is required, at minimum, to access the ACCOUNT_USAGE schema in the SNOWFLAKE database?"
    their_options:
      option A: "SYSADMIN"
      option B: "ACCOUNTADMIN"
      option C: "Any role with IMPORTED PRIVILEGES on the SNOWFLAKE database"
      option D: "PUBLIC"
    correct Answer: "C"
    explanation: >
      C is correct because access to the ACCOUNT_USAGE schema requires IMPORTED PRIVILEGES
      granted on the SNOWFLAKE database. By default, only ACCOUNTADMIN has this, but it can
      be granted to other roles. A is wrong because SYSADMIN does not have access by default.
      B is partially correctâ€”ACCOUNTADMIN has access by default, but it is not the minimum
      requirement since IMPORTED PRIVILEGES can be granted to any role. D is wrong because
      PUBLIC does not have access to the SNOWFLAKE database.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "013"
    question: "What is the latency of data in the ACCOUNT_USAGE schema views?"
    their_options:
      option A: "Real-time (no latency)"
      option B: "Up to 45 minutes"
      option C: "Up to 3 hours"
      option D: "Up to 24 hours"
    correct Answer: "C"
    explanation: >
      C is correct because ACCOUNT_USAGE views can have a data latency of up to 45 minutes
      to 3 hours depending on the view. The commonly cited latency is up to 3 hours for most
      views. A is wrong because ACCOUNT_USAGE is not real-time. B is a lower bound for some
      views but not the general answer. D is wrong; 24 hours is too long.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "014"
    question: "Which SQL query would return credit consumption for the last 30 days grouped by warehouse?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME, SUM(CREDITS_USED)
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('day', -30, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME ORDER BY 2 DESC;
      option B: >
        SELECT WAREHOUSE_NAME, SUM(CREDITS_USED)
        FROM INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('day', -30, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME ORDER BY 2 DESC;
      option C: >
        SELECT WAREHOUSE_NAME, CREDITS_USED
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE START_TIME >= DATEADD('day', -30, CURRENT_TIMESTAMP());
      option D: >
        SELECT * FROM TABLE(INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY(
        DATE_RANGE_START => DATEADD('day', -30, CURRENT_TIMESTAMP())));
    correct Answer: "A"
    explanation: >
      A is correct because it queries the ACCOUNT_USAGE schema which supports 365 days of
      history and properly groups and sums credits by warehouse. B is wrong because the
      INFORMATION_SCHEMA version only retains 14 days and the syntax for calling it is
      different (table function). C is wrong because QUERY_HISTORY does not have a
      CREDITS_USED column. D uses the correct table function syntax for INFORMATION_SCHEMA
      but only supports up to 14 days, which would fail for a 30-day range.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "015"
    question: "What is the key difference between WAREHOUSE_METERING_HISTORY in INFORMATION_SCHEMA vs ACCOUNT_USAGE?"
    their_options:
      option A: "INFORMATION_SCHEMA shows more columns"
      option B: "ACCOUNT_USAGE has up to 365 days of data and up to 3 hours latency; INFORMATION_SCHEMA has 14 days and no latency"
      option C: "INFORMATION_SCHEMA requires ACCOUNTADMIN role; ACCOUNT_USAGE does not"
      option D: "There is no difference; they are identical"
    correct Answer: "B"
    explanation: >
      B is correct. The ACCOUNT_USAGE version retains data for up to 365 days but has latency
      of up to 3 hours, while the INFORMATION_SCHEMA version has only 14 days of data but
      minimal latency (near real-time). A is wrong because they have similar columns. C is
      wrong because it is ACCOUNT_USAGE that requires IMPORTED PRIVILEGES (defaulting to
      ACCOUNTADMIN). D is wrong because they differ significantly in retention and latency.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "016"
    question: "Which resource monitor property defines the credit quota for a given period?"
    their_options:
      option A: "CREDIT_LIMIT"
      option B: "CREDIT_QUOTA"
      option C: "MAX_CREDITS"
      option D: "CREDIT_THRESHOLD"
    correct Answer: "B"
    explanation: >
      B is correct because CREDIT_QUOTA is the property used in a resource monitor to set the
      number of credits allowed for the monitoring period. A (CREDIT_LIMIT) is not the correct
      property name. C (MAX_CREDITS) and D (CREDIT_THRESHOLD) are not valid resource monitor
      properties.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "017"
    question: "What are the THREE trigger actions available for resource monitors? (Select THREE)"
    their_options:
      option A: "NOTIFY"
      option B: "SUSPEND"
      option C: "SUSPEND_IMMEDIATE"
      option D: "TERMINATE"
      option E: "SCALE_DOWN"
    correct Answer: "A, B, C"
    explanation: >
      A, B, and C are correct. Resource monitors support three trigger actions: NOTIFY (sends
      a notification), SUSPEND (suspends the warehouse after currently running queries complete),
      and SUSPEND_IMMEDIATE (suspends the warehouse immediately, canceling running queries).
      D (TERMINATE) is not a valid action. E (SCALE_DOWN) is not a valid resource monitor action.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "018"
    question: "Who receives notifications when a resource monitor trigger fires a NOTIFY action?"
    their_options:
      option A: "All users in the account"
      option B: "Only the warehouse owner"
      option C: "Account administrators (users with ACCOUNTADMIN role) who have enabled notifications"
      option D: "The SYSADMIN role automatically"
    correct Answer: "C"
    explanation: >
      C is correct because resource monitor notifications are sent to account administrators
      who have enabled notifications in the web UI. A is wrong because not all users receive
      the notification. B is wrong because the warehouse owner is not specifically targeted.
      D is wrong because SYSADMIN does not automatically receive these notifications.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "019"
    question: "What is the syntax to create a resource monitor with a monthly credit quota of 1000 credits?"
    their_options:
      option A: >
        CREATE RESOURCE MONITOR my_monitor WITH CREDIT_QUOTA = 1000
        FREQUENCY = MONTHLY START_TIMESTAMP = IMMEDIATELY
        TRIGGERS ON 90 PERCENT DO NOTIFY
        ON 100 PERCENT DO SUSPEND;
      option B: >
        CREATE RESOURCE MONITOR my_monitor SET CREDIT_LIMIT = 1000
        PERIOD = MONTHLY
        TRIGGERS ON 100 PERCENT DO STOP;
      option C: >
        CREATE MONITOR my_monitor WITH CREDIT_QUOTA = 1000
        FREQUENCY = MONTHLY;
      option D: >
        ALTER WAREHOUSE SET RESOURCE_MONITOR = 'my_monitor'
        CREDIT_QUOTA = 1000;
    correct Answer: "A"
    explanation: >
      A is correct because it uses the proper syntax: CREATE RESOURCE MONITOR with
      CREDIT_QUOTA, FREQUENCY = MONTHLY, START_TIMESTAMP, and valid trigger actions
      (NOTIFY and SUSPEND). B is wrong because CREDIT_LIMIT and PERIOD are not valid
      properties, and STOP is not a valid action. C is wrong because the object type is
      RESOURCE MONITOR, not MONITOR, and it lacks triggers. D is wrong because it is an
      ALTER statement and resource monitors are created separately from warehouses.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "020"
    question: "What happens when a resource monitor with a SUSPEND action reaches its threshold while queries are still running?"
    their_options:
      option A: "All running queries are immediately cancelled"
      option B: "Running queries are allowed to complete, then the warehouse is suspended"
      option C: "The warehouse continues running until manually suspended"
      option D: "An error is thrown and the warehouse restarts"
    correct Answer: "B"
    explanation: >
      B is correct because the SUSPEND action allows currently executing queries to complete
      before suspending the warehouse. No new queries can start. A describes
      SUSPEND_IMMEDIATE behavior, not SUSPEND. C is wrong because the warehouse will be
      suspended automatically after queries finish. D is wrong; no error or restart occurs.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "021"
    question: "What happens when a resource monitor with SUSPEND_IMMEDIATE action reaches its threshold?"
    their_options:
      option A: "Running queries are allowed to finish, then the warehouse is suspended"
      option B: "All running queries are immediately cancelled and the warehouse is suspended"
      option C: "Only SELECT queries are cancelled; DML queries finish"
      option D: "The warehouse is paused after a 5-minute grace period"
    correct Answer: "B"
    explanation: >
      B is correct because SUSPEND_IMMEDIATE cancels all currently running queries immediately
      and suspends the warehouse right away. A describes the SUSPEND action instead. C is wrong
      because no distinction is made between query types. D is wrong because there is no grace
      period with SUSPEND_IMMEDIATE.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "022"
    question: "Which role can create resource monitors?"
    their_options:
      option A: "Any role with CREATE WAREHOUSE privilege"
      option B: "SYSADMIN or higher"
      option C: "ACCOUNTADMIN only"
      option D: "Any role with MONITOR privilege"
    correct Answer: "C"
    explanation: >
      C is correct because only the ACCOUNTADMIN role can create resource monitors. This is a
      key distinction in Snowflake's access control. A is wrong because warehouse creation
      privileges do not include resource monitor creation. B is wrong because SYSADMIN cannot
      create resource monitors. D is wrong because MONITOR privilege is for monitoring, not
      creating resource monitors.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "023"
    question: "A resource monitor is set at the ACCOUNT level. How does this affect warehouses?"
    their_options:
      option A: "Only warehouses explicitly assigned to the monitor are affected"
      option B: "All warehouses in the account are collectively monitored against the credit quota"
      option C: "Each warehouse gets its own individual copy of the credit quota"
      option D: "Only the default warehouse is monitored"
    correct Answer: "B"
    explanation: >
      B is correct because when a resource monitor is set at the account level, the credit
      quota applies to the total credit consumption of ALL warehouses in the account
      combined. A is wrong because account-level monitors apply to all warehouses. C is wrong
      because the quota is shared, not duplicated per warehouse. D is wrong because all
      warehouses are included, not just the default one.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "024"
    question: "Can a single warehouse be assigned to multiple resource monitors?"
    their_options:
      option A: "Yes, up to 5 resource monitors per warehouse"
      option B: "Yes, unlimited resource monitors per warehouse"
      option C: "No, a warehouse can only be assigned to one resource monitor at a time (in addition to any account-level monitor)"
      option D: "No, resource monitors can only be set at the account level"
    correct Answer: "C"
    explanation: >
      C is correct because each warehouse can be assigned to at most one warehouse-level
      resource monitor. However, an account-level resource monitor can also apply. So
      effectively, a warehouse can be governed by both a warehouse-level and account-level
      monitor. A and B are wrong because multiple warehouse-level monitors cannot be assigned.
      D is wrong because resource monitors can be assigned to individual warehouses too.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "025"
    question: "How do you assign an existing resource monitor to a warehouse?"
    their_options:
      option A: "ALTER RESOURCE MONITOR my_monitor ADD WAREHOUSE my_wh;"
      option B: "ALTER WAREHOUSE my_wh SET RESOURCE_MONITOR = my_monitor;"
      option C: "GRANT MONITOR my_monitor TO WAREHOUSE my_wh;"
      option D: "SET WAREHOUSE my_wh RESOURCE_MONITOR = my_monitor;"
    correct Answer: "B"
    explanation: >
      B is correct because you use ALTER WAREHOUSE ... SET RESOURCE_MONITOR = <monitor_name>
      to assign a resource monitor to a specific warehouse. A is wrong because the syntax is
      on the warehouse, not the monitor. C is wrong because GRANT MONITOR is not valid syntax
      for this purpose. D is wrong because SET is not a standalone command for this.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "026"
    question: "What is the FREQUENCY property of a resource monitor?"
    their_options:
      option A: "How often the monitor sends notifications"
      option B: "The interval at which the credit quota resets (MONTHLY, DAILY, WEEKLY, YEARLY, NEVER)"
      option C: "How often the monitor checks credit usage"
      option D: "The polling interval for warehouse metrics"
    correct Answer: "B"
    explanation: >
      B is correct because FREQUENCY defines the interval at which the credit quota resets.
      Valid values include MONTHLY, DAILY, WEEKLY, YEARLY, and NEVER. A is wrong because
      notifications are triggered by thresholds, not frequency. C and D are wrong because
      the monitor continuously checks usage; FREQUENCY refers to the reset cycle.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "027"
    question: "What does it mean when the resource monitor FREQUENCY is set to NEVER?"
    their_options:
      option A: "The monitor is disabled"
      option B: "The credit quota never resets; it is a one-time lifetime quota"
      option C: "The monitor never sends notifications"
      option D: "The monitor is deleted after the first trigger"
    correct Answer: "B"
    explanation: >
      B is correct because FREQUENCY = NEVER means the credit quota is a one-time allocation
      that does not reset. Once the credits are consumed, they do not replenish. A is wrong
      because the monitor is still active. C is wrong because notifications are still sent
      based on triggers. D is wrong because the monitor is not deleted.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "028"
    question: "You set a resource monitor with CREDIT_QUOTA = 500, FREQUENCY = MONTHLY, and a trigger ON 80 PERCENT DO NOTIFY. When will the notification be sent?"
    their_options:
      option A: "When 80 credits have been used"
      option B: "When 400 credits have been used in the current month"
      option C: "When 80% of the warehouse compute time has been used"
      option D: "When 400 credits remain"
    correct Answer: "B"
    explanation: >
      B is correct because 80% of the 500 credit quota = 400 credits. When cumulative credit
      usage reaches 400 credits within the current monthly period, the NOTIFY action triggers.
      A is wrong (80 is 16% of 500). C is wrong because resource monitors track credits, not
      compute time directly. D is wrong because the trigger is based on credits consumed, not
      credits remaining.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "029"
    question: "Which view can you use to check the current credit usage and remaining quota for resource monitors?"
    their_options:
      option A: "RESOURCE_MONITORS (using SHOW RESOURCE MONITORS)"
      option B: "WAREHOUSE_METERING_HISTORY"
      option C: "CREDIT_USAGE_HISTORY"
      option D: "ACCOUNT_USAGE.RESOURCE_MONITORS"
    correct Answer: "A"
    explanation: >
      A is correct because SHOW RESOURCE MONITORS displays the current state of all resource
      monitors including credit quota, credits used, remaining credits, and trigger settings.
      B is wrong because it shows metering history, not resource monitor state. C is wrong
      because it is not a standard view. D is wrong; while RESOURCE_MONITORS exists in
      ACCOUNT_USAGE, the quickest way to check current state is SHOW RESOURCE MONITORS.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "030"
    question: "What does the QUERY_HISTORY view provide that is useful for warehouse monitoring?"
    their_options:
      option A: "Only the SQL text of executed queries"
      option B: "Query execution details including warehouse used, execution time, bytes scanned, and compilation time"
      option C: "Only the number of queries per warehouse"
      option D: "Only failed queries"
    correct Answer: "B"
    explanation: >
      B is correct because QUERY_HISTORY provides comprehensive details about each query
      including the warehouse used, execution time, bytes scanned, rows produced, compilation
      time, and much more. A is wrong because it includes far more than just SQL text. C is
      wrong because individual query details are available, not just counts. D is wrong because
      it includes all queries, not just failed ones.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "031"
    question: "A company wants to monitor warehouse costs in real-time. Which approach is MOST appropriate?"
    their_options:
      option A: "Query ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY every minute"
      option B: "Use INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY table function for near real-time data"
      option C: "Use SHOW WAREHOUSES to check credits"
      option D: "Query SNOWFLAKE.ORGANIZATION_USAGE.WAREHOUSE_METERING_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because the INFORMATION_SCHEMA version has minimal latency (near real-time)
      compared to ACCOUNT_USAGE which has up to 3 hours of latency. For real-time monitoring,
      INFORMATION_SCHEMA is the better choice. A is wrong because ACCOUNT_USAGE has significant
      latency. C is wrong because SHOW WAREHOUSES does not show credit consumption details.
      D is wrong because ORGANIZATION_USAGE is for org-level billing, not real-time warehouse
      monitoring.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "032"
    question: "What is the purpose of the AUTO_SUSPEND parameter on a virtual warehouse?"
    their_options:
      option A: "To automatically delete the warehouse after a period of inactivity"
      option B: "To automatically suspend (pause) the warehouse after a specified number of seconds of inactivity"
      option C: "To set the maximum runtime for any single query"
      option D: "To automatically scale down the warehouse size"
    correct Answer: "B"
    explanation: >
      B is correct because AUTO_SUSPEND defines the number of seconds of inactivity after
      which the warehouse is automatically suspended, stopping credit consumption. A is wrong
      because suspend does not delete the warehouse. C is wrong because query timeout is
      handled by STATEMENT_TIMEOUT_IN_SECONDS. D is wrong because AUTO_SUSPEND does not change
      the warehouse size.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst, Architect

  - Question No: "033"
    question: "What is the minimum value for AUTO_SUSPEND?"
    their_options:
      option A: "0 seconds (disable auto-suspend)"
      option B: "1 second"
      option C: "60 seconds (1 minute)"
      option D: "300 seconds (5 minutes)"
    correct Answer: "C"
    explanation: >
      C is correct because the minimum AUTO_SUSPEND value is 60 seconds. You can also set it
      to 0 or NULL to disable auto-suspend entirely, but 60 is the minimum active suspension
      timer. A (0) disables auto-suspend rather than being a suspend time. B (1 second) is
      below the minimum allowed. D (300 seconds) was the old default but not the minimum.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "034"
    question: "What happens when AUTO_RESUME is set to TRUE on a warehouse?"
    their_options:
      option A: "The warehouse automatically resumes when a query is submitted to it"
      option B: "The warehouse resumes on a scheduled time every day"
      option C: "The warehouse cannot be manually suspended"
      option D: "The warehouse automatically scales up when load increases"
    correct Answer: "A"
    explanation: >
      A is correct because AUTO_RESUME = TRUE means the warehouse will automatically start
      when a SQL statement (query, DML, etc.) is submitted that requires it. B is wrong
      because AUTO_RESUME is event-driven, not time-based. C is wrong because the warehouse
      can still be manually suspended. D is wrong because AUTO_RESUME is about starting a
      suspended warehouse, not scaling.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "035"
    question: "Which query shows the total number of queries executed on each warehouse in the last 7 days?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME, COUNT(*) as QUERY_COUNT
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME ORDER BY QUERY_COUNT DESC;
      option B: >
        SELECT WAREHOUSE_NAME, QUERY_COUNT
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_LOAD_HISTORY
        WHERE START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP());
      option C: >
        SELECT * FROM TABLE(INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY(
        DATE_RANGE_START => DATEADD('day', -7, CURRENT_TIMESTAMP())));
      option D: >
        SHOW QUERIES LIMIT 1000;
    correct Answer: "A"
    explanation: >
      A is correct because it queries QUERY_HISTORY, counts all queries, groups by warehouse
      name, and filters for the last 7 days. B is wrong because WAREHOUSE_LOAD_HISTORY does
      not have a QUERY_COUNT column. C is wrong because WAREHOUSE_METERING_HISTORY tracks
      credits, not query counts. D is wrong because SHOW QUERIES is not a valid command (it
      should be SHOW QUERIES or similar but does not support this aggregation).
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "036"
    question: "What is the QUERY_ACCELERATION_HISTORY view used for?"
    their_options:
      option A: "Tracking queries that used the query acceleration service and the credits consumed"
      option B: "Tracking queries that were accelerated by caching"
      option C: "Monitoring the speed improvement of each query"
      option D: "Viewing the history of warehouse size changes"
    correct Answer: "A"
    explanation: >
      A is correct because QUERY_ACCELERATION_HISTORY tracks the usage and credit consumption
      of the Query Acceleration Service (QAS). B is wrong because caching is separate from
      QAS. C is wrong because it does not measure speed improvement directly. D is wrong
      because warehouse resizing is not tracked here.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "037"
    question: "Which parameter controls the maximum scale factor for the Query Acceleration Service?"
    their_options:
      option A: "QUERY_ACCELERATION_MAX_SCALE_FACTOR"
      option B: "MAX_QUERY_ACCELERATION"
      option C: "QAS_SCALE_FACTOR"
      option D: "ACCELERATION_LIMIT"
    correct Answer: "A"
    explanation: >
      A is correct because QUERY_ACCELERATION_MAX_SCALE_FACTOR is the parameter that sets
      the upper bound for the scale factor of the Query Acceleration Service. B, C, and D
      are not valid Snowflake parameter names.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "038"
    question: "A warehouse has been running for 45 seconds and then goes idle. How many seconds of credit are billed?"
    their_options:
      option A: "45 seconds"
      option B: "60 seconds (minimum 1-minute billing)"
      option C: "0 seconds (under 1 minute threshold)"
      option D: "300 seconds (minimum 5-minute billing)"
    correct Answer: "B"
    explanation: >
      B is correct because Snowflake has a minimum billing of 60 seconds (1 minute) when a
      warehouse starts. Even if the warehouse only runs for 45 seconds, you are billed for
      the full 60 seconds. A is wrong because billing is not pro-rated below 60 seconds.
      C is wrong because there is no free threshold. D is wrong; the minimum billing is
      60 seconds, not 300.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "039"
    question: "After the initial 60-second minimum, how is warehouse billing calculated?"
    their_options:
      option A: "Per-minute increments"
      option B: "Per-second increments"
      option C: "Per-hour increments"
      option D: "Per-query increments"
    correct Answer: "B"
    explanation: >
      B is correct because after the initial 60-second minimum, Snowflake bills in per-second
      increments. So if a warehouse runs for 90 seconds, you are billed for 90 seconds. A is
      wrong; it is per-second after the first minute, not per-minute. C and D are incorrect
      billing granularities.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "040"
    question: "Which view would you query to analyze the performance of individual queries on a warehouse?"
    their_options:
      option A: "WAREHOUSE_LOAD_HISTORY"
      option B: "WAREHOUSE_METERING_HISTORY"
      option C: "QUERY_HISTORY"
      option D: "WAREHOUSE_EVENTS_HISTORY"
    correct Answer: "C"
    explanation: >
      C is correct because QUERY_HISTORY contains per-query performance metrics such as
      execution time, compilation time, bytes scanned, rows returned, and more. A is wrong
      because WAREHOUSE_LOAD_HISTORY shows aggregate load, not individual queries. B is wrong
      because WAREHOUSE_METERING_HISTORY tracks credits, not query performance. D is wrong
      because WAREHOUSE_EVENTS_HISTORY tracks warehouse state changes, not query metrics.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "041"
    question: "Which column in QUERY_HISTORY indicates the time a query spent waiting for warehouse resources?"
    their_options:
      option A: "EXECUTION_TIME"
      option B: "COMPILATION_TIME"
      option C: "QUEUED_OVERLOAD_TIME"
      option D: "TOTAL_ELAPSED_TIME"
    correct Answer: "C"
    explanation: >
      C is correct because QUEUED_OVERLOAD_TIME indicates the time a query spent queued
      because the warehouse was overloaded. A (EXECUTION_TIME) is the actual execution
      duration. B (COMPILATION_TIME) is the time spent compiling the query. D
      (TOTAL_ELAPSED_TIME) is the total wall-clock time including all phases.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "042"
    question: "A query has high QUEUED_PROVISIONING_TIME. What does this indicate?"
    their_options:
      option A: "The query is waiting because the warehouse is overloaded with other queries"
      option B: "The query is waiting while the warehouse is being provisioned (starting up or resizing)"
      option C: "The query has a syntax error"
      option D: "The query is waiting for a lock on a table"
    correct Answer: "B"
    explanation: >
      B is correct because QUEUED_PROVISIONING_TIME measures time spent waiting while the
      warehouse is being provisioned, meaning it is starting up from a suspended state or
      resizing. A describes QUEUED_OVERLOAD_TIME. C is wrong because syntax errors would
      cause immediate failure. D describes QUEUED_BLOCKED_TIME (blocked by transaction locks).
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "043"
    question: "Which TWO columns in QUERY_HISTORY help identify queries that may benefit from a larger warehouse? (Select TWO)"
    their_options:
      option A: "BYTES_SPILLED_TO_LOCAL_STORAGE"
      option B: "QUERY_TEXT"
      option C: "BYTES_SPILLED_TO_REMOTE_STORAGE"
      option D: "USER_NAME"
      option E: "QUERY_TAG"
    correct Answer: "A, C"
    explanation: >
      A and C are correct. BYTES_SPILLED_TO_LOCAL_STORAGE and BYTES_SPILLED_TO_REMOTE_STORAGE
      indicate data spillage during query processing, which happens when a warehouse does not
      have enough memory. Significant spillage suggests the warehouse needs to be upsized.
      B (QUERY_TEXT) is the SQL text and doesn't indicate sizing needs. D (USER_NAME) and
      E (QUERY_TAG) are metadata fields, not performance indicators.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "044"
    question: "What is data spillage in the context of warehouse monitoring?"
    their_options:
      option A: "Data leaking between warehouses"
      option B: "When query processing exceeds the warehouse memory, data overflows to local or remote disk storage"
      option C: "When data is accidentally deleted during processing"
      option D: "When too many queries are queued"
    correct Answer: "B"
    explanation: >
      B is correct because data spillage occurs when a query's intermediate results exceed
      available memory, forcing data to be written to local SSD storage or even remote cloud
      storage. This degrades performance. A is wrong because warehouses are isolated. C is
      wrong because spillage is not about data deletion. D is wrong because queuing is
      separate from spillage.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "045"
    question: "What is the correct order of data spillage severity?"
    their_options:
      option A: "Remote storage spillage > Local storage spillage > No spillage"
      option B: "No spillage > Local storage spillage > Remote storage spillage"
      option C: "Local storage spillage > Remote storage spillage > No spillage"
      option D: "All spillage types have equal performance impact"
    correct Answer: "A"
    explanation: >
      A is correct. Remote storage spillage is the most severe (slowest) because data must
      be written to and read from cloud storage. Local storage spillage (to SSD) is less
      severe but still indicates insufficient memory. No spillage is ideal. B presents the
      order reversed. C reverses the severity of local vs remote. D is wrong because remote
      spillage has significantly more impact than local.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "046"
    question: "In Snowsight, the Query Profile shows a query step with a high percentage in 'Processing'. What does this typically indicate?"
    their_options:
      option A: "The query is waiting for warehouse provisioning"
      option B: "The query is spending significant time on computation (joins, aggregations, sorting)"
      option C: "The query is waiting for data to be loaded from external stages"
      option D: "The query is blocked by a concurrent transaction"
    correct Answer: "B"
    explanation: >
      B is correct because high Processing time in Query Profile indicates the query is
      spending significant time on computation operations like joins, aggregations, and
      sorting. A describes provisioning wait time, shown separately. C is about data loading,
      not processing. D would appear as blocked time, not processing.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "047"
    question: "How can you identify long-running queries consuming warehouse resources?"
    their_options:
      option A: "SHOW WAREHOUSES LIKE '%long%'"
      option B: >
        SELECT QUERY_ID, QUERY_TEXT, TOTAL_ELAPSED_TIME, WAREHOUSE_NAME
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE TOTAL_ELAPSED_TIME > 300000
        ORDER BY TOTAL_ELAPSED_TIME DESC;
      option C: "DESCRIBE WAREHOUSE my_wh"
      option D: "SELECT * FROM WAREHOUSE_PARAMETERS WHERE PARAM = 'LONG_QUERIES'"
    correct Answer: "B"
    explanation: >
      B is correct because it queries QUERY_HISTORY for queries where TOTAL_ELAPSED_TIME
      exceeds 300000 milliseconds (5 minutes), ordered by duration. This effectively
      identifies long-running queries. A is wrong because SHOW WAREHOUSES does not show
      query info. C is wrong because DESCRIBE WAREHOUSE is not a valid command for this.
      D is wrong because WAREHOUSE_PARAMETERS with LONG_QUERIES does not exist.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "048"
    question: "What does the WAREHOUSE_EVENTS_HISTORY view track?"
    their_options:
      option A: "Query execution events within a warehouse"
      option B: "Warehouse state changes such as start, suspend, resume, and resize events"
      option C: "User login events to the warehouse"
      option D: "Data loading events via COPY INTO"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_EVENTS_HISTORY captures warehouse lifecycle events
      including CREATE, SUSPEND, RESUME, RESIZE, and DROP operations. A is wrong because
      query events are in QUERY_HISTORY. C is wrong because login events are in LOGIN_HISTORY.
      D is wrong because data loading events are tracked in COPY_HISTORY.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "049"
    question: "A multi-cluster warehouse is configured with MIN_CLUSTER_COUNT = 1 and MAX_CLUSTER_COUNT = 5 in Auto-scale mode. How can you monitor the actual number of clusters running?"
    their_options:
      option A: "Query WAREHOUSE_METERING_HISTORY and check the number of credits (more credits = more clusters)"
      option B: "Use SHOW WAREHOUSES and check the running column"
      option C: "Query WAREHOUSE_EVENTS_HISTORY for cluster start/stop events"
      option D: "Both B and C can provide this information"
    correct Answer: "D"
    explanation: >
      D is correct. SHOW WAREHOUSES includes columns like running and queued that show the
      current cluster state. WAREHOUSE_EVENTS_HISTORY logs cluster scale-up and scale-down
      events, providing historical cluster count changes. A provides indirect information but
      is not the best way to monitor active clusters. B and C are both valid approaches for
      current and historical cluster counts respectively.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "050"
    question: "What is the STATEMENT_TIMEOUT_IN_SECONDS parameter used for?"
    their_options:
      option A: "Setting the time after which a warehouse auto-suspends"
      option B: "Setting the maximum time a statement (query) can run before being automatically cancelled"
      option C: "Setting the time limit for warehouse provisioning"
      option D: "Setting the timeout for user sessions"
    correct Answer: "B"
    explanation: >
      B is correct because STATEMENT_TIMEOUT_IN_SECONDS sets the maximum number of seconds
      a SQL statement can run before Snowflake cancels it. This helps prevent runaway queries
      from consuming excessive warehouse resources. A describes AUTO_SUSPEND. C is not a
      configurable parameter. D describes SESSION timeout, which is different.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "051"
    question: "At which levels can STATEMENT_TIMEOUT_IN_SECONDS be set? (Select THREE)"
    their_options:
      option A: "Account level"
      option B: "Warehouse level"
      option C: "Session level"
      option D: "Database level"
      option E: "Schema level"
    correct Answer: "A, B, C"
    explanation: >
      A, B, and C are correct. STATEMENT_TIMEOUT_IN_SECONDS can be set at the account level,
      warehouse level, and session level. The most restrictive (lowest non-zero) value takes
      precedence. D (database level) and E (schema level) are not valid levels for this
      parameter.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "052"
    question: "Your company's monthly Snowflake bill has doubled. Which combination of views gives the MOST comprehensive analysis of credit consumption? (Select TWO)"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY"
      option B: "QUERY_HISTORY"
      option C: "LOGIN_HISTORY"
      option D: "STORAGE_USAGE"
      option E: "DATA_TRANSFER_HISTORY"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. WAREHOUSE_METERING_HISTORY shows which warehouses consumed the
      most credits, and QUERY_HISTORY reveals which specific queries drove the consumption.
      Together, they provide a comprehensive picture. C (LOGIN_HISTORY) does not show costs.
      D (STORAGE_USAGE) tracks storage costs, not compute. E (DATA_TRANSFER_HISTORY) tracks
      transfer costs. While D and E could also contribute to billing analysis, A and B are
      most comprehensive for the compute-driven cost increase scenario.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "053"
    question: "Which Snowflake function provides a visual representation of a query's execution plan?"
    their_options:
      option A: "EXPLAIN"
      option B: "QUERY_PROFILE (in Snowsight)"
      option C: "DESCRIBE QUERY"
      option D: "SHOW PLAN"
    correct Answer: "B"
    explanation: >
      B is correct because the Query Profile in Snowsight provides a visual, graphical
      representation of a query's execution plan, showing operator nodes, data flow, and
      performance metrics. A (EXPLAIN) provides a text-based execution plan but not a visual
      representation. C and D are not valid Snowflake commands.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "054"
    question: "What does the 'percentage scanned from cache' metric in Query Profile indicate?"
    their_options:
      option A: "The percentage of the query result served from the result cache"
      option B: "The percentage of data read from the local disk cache (SSD) instead of remote storage"
      option C: "The percentage of metadata read from the metadata cache"
      option D: "The percentage of data stored in the warehouse memory"
    correct Answer: "B"
    explanation: >
      B is correct because 'percentage scanned from cache' in Query Profile refers to the
      proportion of data that was read from the local SSD cache on the warehouse nodes rather
      than from remote cloud storage. A is wrong because result cache is different (it serves
      entire query results). C is wrong because metadata cache is separate. D is wrong because
      it refers to cache reads, not data stored in memory.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "055"
    question: "A query's TOTAL_ELAPSED_TIME is 120 seconds, but EXECUTION_TIME is only 10 seconds. What is the most likely explanation?"
    their_options:
      option A: "The query was very complex with many joins"
      option B: "The query spent significant time queued (provisioning or overload) or in compilation"
      option C: "The TOTAL_ELAPSED_TIME is calculated incorrectly"
      option D: "The warehouse was too large for the query"
    correct Answer: "B"
    explanation: >
      B is correct because TOTAL_ELAPSED_TIME includes all phases: queuing (provisioning or
      overload), compilation, and execution. If EXECUTION_TIME is only 10 seconds out of 120,
      the remaining 110 seconds were likely spent in queuing or compilation. A is wrong because
      complex queries would show higher EXECUTION_TIME. C is wrong; the metric is accurate.
      D is wrong because a larger warehouse would not cause such a discrepancy.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "056"
    question: "What does the CLUSTER_NUMBER column represent in QUERY_HISTORY for multi-cluster warehouses?"
    their_options:
      option A: "The total number of clusters in the warehouse"
      option B: "The specific cluster (node) within the multi-cluster warehouse that executed the query"
      option C: "The number of clusters the query spanned"
      option D: "The cluster identifier for database replication"
    correct Answer: "B"
    explanation: >
      B is correct because CLUSTER_NUMBER identifies which specific cluster in a multi-cluster
      warehouse executed the query. A is wrong because it shows the assigned cluster, not the
      total count. C is wrong because a query runs on one cluster. D is wrong because this is
      about warehouse clusters, not replication clusters.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "057"
    question: "What privilege is needed to monitor a warehouse using SHOW WAREHOUSES?"
    their_options:
      option A: "OWNERSHIP on the warehouse"
      option B: "MONITOR or any higher privilege (OPERATE, MODIFY, OWNERSHIP) on the warehouse"
      option C: "USAGE on the warehouse"
      option D: "No privilege is needed; all roles can see all warehouses"
    correct Answer: "C"
    explanation: >
      C is correct because SHOW WAREHOUSES displays warehouses that the current role has any
      privilege on, including USAGE. The USAGE privilege is sufficient to see the warehouse
      listed. B is partially correct in that MONITOR provides additional monitoring capabilities,
      but USAGE is the minimum to see the warehouse in SHOW WAREHOUSES. A is too restrictive.
      D is wrong because you need at least some privilege on the warehouse.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "058"
    question: "What does the MONITOR privilege on a warehouse allow?"
    their_options:
      option A: "Create resource monitors for the warehouse"
      option B: "View usage and performance statistics for the warehouse"
      option C: "Modify warehouse parameters"
      option D: "Resume and suspend the warehouse"
    correct Answer: "B"
    explanation: >
      B is correct because the MONITOR privilege allows viewing warehouse utilization and
      performance statistics. A is wrong because creating resource monitors requires
      ACCOUNTADMIN. C is wrong because modifying parameters requires the MODIFY privilege.
      D is wrong because resume and suspend require the OPERATE privilege.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "059"
    question: "Which privilege is required to suspend or resume a warehouse?"
    their_options:
      option A: "MONITOR"
      option B: "OPERATE"
      option C: "MODIFY"
      option D: "USAGE"
    correct Answer: "B"
    explanation: >
      B is correct because the OPERATE privilege allows starting, stopping (suspending), and
      resuming a warehouse, as well as aborting queries. A (MONITOR) only allows viewing
      statistics. C (MODIFY) allows changing warehouse properties. D (USAGE) allows using
      the warehouse to execute queries.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "060"
    question: "A data analyst reports that their queries are running slowly on warehouse 'ANALYTICS_WH'. Which metric in WAREHOUSE_LOAD_HISTORY should you check first?"
    their_options:
      option A: "CREDITS_USED"
      option B: "AVG_QUEUED_LOAD"
      option C: "AVG_QUEUED_PROVISIONING"
      option D: "Both B and C"
    correct Answer: "D"
    explanation: >
      D is correct because you should check both AVG_QUEUED_LOAD (queries waiting due to
      overloaded warehouse) and AVG_QUEUED_PROVISIONING (queries waiting during warehouse
      provisioning). Both indicate potential causes of slow performance. A (CREDITS_USED)
      is in a different view and doesn't directly indicate slow queries. Checking both B
      and C together gives a comprehensive view of queuing issues.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "061"
    question: "What does it mean if AVG_RUNNING in WAREHOUSE_LOAD_HISTORY is consistently close to the warehouse's cluster count multiplied by its server count?"
    their_options:
      option A: "The warehouse is idle"
      option B: "The warehouse is at maximum capacity and may need to be scaled up or out"
      option C: "The warehouse is underutilized and should be scaled down"
      option D: "The warehouse is experiencing errors"
    correct Answer: "B"
    explanation: >
      B is correct because if AVG_RUNNING is consistently near the warehouse's maximum
      concurrency capacity, it means the warehouse is operating at or near full capacity.
      This suggests scaling up (larger size) or out (more clusters in multi-cluster mode)
      may be needed. A is wrong because idle would show low AVG_RUNNING. C is wrong because
      high utilization is the opposite of underutilization. D is wrong because high utilization
      is not an error condition.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "062"
    question: "Which SQL command allows you to cancel a running query on a warehouse?"
    their_options:
      option A: "CANCEL QUERY <query_id>"
      option B: "SELECT SYSTEM$CANCEL_QUERY('<query_id>')"
      option C: "ABORT QUERY <query_id>"
      option D: "KILL QUERY <query_id>"
    correct Answer: "B"
    explanation: >
      B is correct because SYSTEM$CANCEL_QUERY is the Snowflake system function used to
      cancel a running or queued query by providing its query ID. A, C, and D use incorrect
      syntax that is not supported in Snowflake.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "063"
    question: "Who can cancel a query running on a warehouse? (Select TWO)"
    their_options:
      option A: "The user who submitted the query"
      option B: "Any user with USAGE privilege on the warehouse"
      option C: "A user with the OPERATE privilege on the warehouse"
      option D: "Only ACCOUNTADMIN"
      option E: "Any user in the same role as the query submitter"
    correct Answer: "A, C"
    explanation: >
      A and C are correct. The user who submitted the query can always cancel their own query.
      Additionally, users with the OPERATE privilege on the warehouse can cancel any query
      running on that warehouse. B is wrong because USAGE only allows submitting queries.
      D is wrong because it is not limited to ACCOUNTADMIN. E is wrong because role membership
      alone does not grant cancel rights.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "064"
    question: "What is the purpose of the SYSTEM$WAREHOUSE_CACHING_METRICS function?"
    their_options:
      option A: "To view the result cache hit ratio for the warehouse"
      option B: "To monitor the local disk cache (SSD) and data cache effectiveness of a warehouse"
      option C: "To clear the warehouse cache"
      option D: "To set cache eviction policies"
    correct Answer: "B"
    explanation: >
      B is wrong - actually this is a tricky question. The correct answer is B because
      SYSTEM$WAREHOUSE_CACHING_METRICS provides information about the effectiveness of
      the local disk cache on warehouse nodes. A is wrong because result cache is separate.
      C is wrong because this function is read-only, not for clearing cache. D is wrong
      because cache eviction is managed automatically by Snowflake.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "065"
    question: "What happens to the local disk cache when a warehouse is suspended?"
    their_options:
      option A: "The cache is preserved and available when the warehouse resumes"
      option B: "The cache is lost because the compute resources are released"
      option C: "The cache is written to remote storage for later retrieval"
      option D: "The cache is moved to another active warehouse"
    correct Answer: "B"
    explanation: >
      B is correct because when a warehouse is suspended, all compute resources are released,
      including local SSD storage that holds the disk cache. When the warehouse resumes, the
      cache is cold and must be rebuilt. A is wrong because the cache is lost on suspend. C is
      wrong because the cache is not persisted to remote storage. D is wrong because caches
      are not transferred between warehouses.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "066"
    question: "Which scenario would show high QUEUED_BLOCKED_TIME in QUERY_HISTORY?"
    their_options:
      option A: "The warehouse is overloaded with too many concurrent queries"
      option B: "A query is waiting for a lock held by a concurrent DML transaction on the same table"
      option C: "The warehouse is starting up from a suspended state"
      option D: "The query has a syntax error"
    correct Answer: "B"
    explanation: >
      B is correct because QUEUED_BLOCKED_TIME represents the time a query spent waiting
      because it was blocked by a concurrent DML operation holding a lock. A describes
      QUEUED_OVERLOAD_TIME. C describes QUEUED_PROVISIONING_TIME. D would cause immediate
      failure, not queuing.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "067"
    question: "How can you view the current queries running on a specific warehouse?"
    their_options:
      option A: >
        SELECT QUERY_ID, QUERY_TEXT, STATUS, WAREHOUSE_NAME
        FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY())
        WHERE WAREHOUSE_NAME = 'MY_WH' AND EXECUTION_STATUS = 'RUNNING';
      option B: "SHOW RUNNING QUERIES ON WAREHOUSE MY_WH"
      option C: "SELECT * FROM TABLE(INFORMATION_SCHEMA.CURRENT_QUERIES())"
      option D: "DESCRIBE WAREHOUSE MY_WH QUERIES"
    correct Answer: "A"
    explanation: >
      A is correct because you can query the INFORMATION_SCHEMA.QUERY_HISTORY table function
      and filter by warehouse name and running status to see currently executing queries.
      B is not valid Snowflake syntax. C is not a valid table function. D is not valid syntax.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "068"
    question: "You want to set up alerts when warehouse credit consumption exceeds a daily threshold. Which approach is BEST?"
    their_options:
      option A: "Create a resource monitor with FREQUENCY = DAILY and appropriate triggers"
      option B: "Manually check WAREHOUSE_METERING_HISTORY every day"
      option C: "Set AUTO_SUSPEND to 0"
      option D: "Use a stored procedure to send emails via external functions"
    correct Answer: "A"
    explanation: >
      A is correct because resource monitors with FREQUENCY = DAILY and NOTIFY triggers
      provide automated daily credit monitoring with built-in notifications. B is manual and
      not scalable. C disabling AUTO_SUSPEND would increase costs, not monitor them. D is
      possible but overly complex compared to the built-in resource monitor feature.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "069"
    question: "What is the default value for AUTO_SUSPEND on a newly created warehouse?"
    their_options:
      option A: "0 (never auto-suspend)"
      option B: "60 seconds"
      option C: "300 seconds (5 minutes)"
      option D: "600 seconds (10 minutes)"
    correct Answer: "D"
    explanation: >
      D is correct because the default AUTO_SUSPEND value for a newly created warehouse is
      600 seconds (10 minutes). A (0) would disable auto-suspend. B (60 seconds) is the
      minimum value. C (300 seconds) is commonly used but not the default.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst, Architect

  - Question No: "070"
    question: "Which credit type is tracked in WAREHOUSE_METERING_HISTORY? (Select TWO)"
    their_options:
      option A: "CREDITS_USED - total credits consumed by the warehouse"
      option B: "CREDITS_USED_CLOUD_SERVICES - credits for cloud services overhead"
      option C: "CREDITS_STORED - credits for data storage"
      option D: "CREDITS_TRANSFERRED - credits for data transfer"
      option E: "CREDITS_REFUNDED - credits returned to the account"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. WAREHOUSE_METERING_HISTORY tracks CREDITS_USED (compute credits)
      and CREDITS_USED_CLOUD_SERVICES (cloud services layer credits associated with warehouse
      operations). C is wrong because storage credits are tracked separately. D is wrong
      because data transfer credits are in a different view. E is wrong because refunds are
      not tracked in this view.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "071"
    question: "What is the cloud services credit adjustment (10% threshold)?"
    their_options:
      option A: "10% of all compute credits are added as a service fee"
      option B: "If cloud services credits are less than 10% of total compute credits, they are waived"
      option C: "Cloud services always cost exactly 10% of compute"
      option D: "10% of credit consumption is reserved for maintenance"
    correct Answer: "B"
    explanation: >
      B is correct. Snowflake provides an automatic daily adjustment where cloud services
      costs that fall below 10% of the total daily compute (warehouse) credit consumption
      are not charged. Only the amount exceeding the 10% threshold is billed. A is wrong
      because it is not an additional fee. C is wrong because the actual cost varies. D is
      wrong because this is not about maintenance reserves.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "072"
    question: "How can you determine if a warehouse is being frequently suspended and resumed (thrashing)?"
    their_options:
      option A: "Query WAREHOUSE_EVENTS_HISTORY for frequent RESUME and SUSPEND events close together"
      option B: "Check WAREHOUSE_METERING_HISTORY for gaps in credit consumption"
      option C: "Check the AUTO_SUSPEND value in SHOW WAREHOUSES"
      option D: "Both A and B can help identify thrashing"
    correct Answer: "D"
    explanation: >
      D is correct because both approaches can identify warehouse thrashing. A directly
      shows frequent suspend/resume events with timestamps. B shows gaps followed by credit
      spikes indicating frequent start/stop cycles. C only shows the configured value, not
      whether thrashing is actually occurring. Combining A and B provides the best analysis.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "073"
    question: "A warehouse has AUTO_SUSPEND = 60 and is handling intermittent queries every 2-3 minutes. What is the cost impact?"
    their_options:
      option A: "No additional cost because queries are within the suspension window"
      option B: "Higher cost due to repeated 60-second minimum billing charges each time the warehouse resumes"
      option C: "Lower cost because the warehouse is efficiently suspending between queries"
      option D: "No cost because AUTO_RESUME handles it automatically"
    correct Answer: "B"
    explanation: >
      B is correct. With AUTO_SUSPEND = 60 and queries every 2-3 minutes, the warehouse
      suspends between queries and must restart, incurring the 60-second minimum billing
      each time. This can actually cost more than keeping the warehouse running continuously.
      A is wrong because the warehouse does suspend in the gap. C is wrong because frequent
      restarts add cost. D is wrong because AUTO_RESUME does not eliminate billing.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "074"
    question: "Which view would you query to find the total cost of Snowflake services including compute, storage, and data transfer?"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY"
      option B: "SNOWFLAKE.ORGANIZATION_USAGE.USAGE_IN_CURRENCY_DAILY"
      option C: "ACCOUNT_USAGE.STORAGE_USAGE"
      option D: "INFORMATION_SCHEMA.BILLING_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because USAGE_IN_CURRENCY_DAILY in the ORGANIZATION_USAGE schema provides
      a comprehensive view of all costs in currency, including compute, storage, and data
      transfer. A only covers warehouse compute credits. C only covers storage. D is not a
      standard Snowflake view.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "075"
    question: "When a multi-cluster warehouse scales out to add clusters, what does each new cluster cost?"
    their_options:
      option A: "Half the credits of the original cluster"
      option B: "The same credits per hour as the original cluster (same warehouse size)"
      option C: "Double the credits to account for provisioning overhead"
      option D: "No additional cost; multi-cluster scaling is free"
    correct Answer: "B"
    explanation: >
      B is correct because each additional cluster in a multi-cluster warehouse consumes the
      same credits per hour as the base cluster, since each cluster has the same size. A is
      wrong because there is no 50% discount. C is wrong because there is no overhead
      multiplier. D is wrong because each cluster is a billable compute resource.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "076"
    question: "Which query helps identify the most expensive queries by credits consumed?"
    their_options:
      option A: >
        SELECT QUERY_ID, QUERY_TEXT, WAREHOUSE_NAME, WAREHOUSE_SIZE,
        EXECUTION_TIME, TOTAL_ELAPSED_TIME
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        ORDER BY EXECUTION_TIME DESC LIMIT 20;
      option B: >
        SELECT QUERY_ID, CREDITS_USED
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        ORDER BY CREDITS_USED DESC LIMIT 20;
      option C: >
        SELECT QUERY_ID, WAREHOUSE_NAME
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        ORDER BY CREDITS_USED DESC LIMIT 20;
      option D: "SHOW EXPENSIVE QUERIES LIMIT 20;"
    correct Answer: "A"
    explanation: >
      A is correct. While QUERY_HISTORY does not have a direct CREDITS_USED column per query,
      ordering by EXECUTION_TIME and considering WAREHOUSE_SIZE provides the best proxy for
      identifying expensive queries. Longer-running queries on larger warehouses consume more
      credits. B is wrong because QUERY_HISTORY does not have a CREDITS_USED column. C is
      wrong because WAREHOUSE_METERING_HISTORY does not have per-query data. D is not valid
      syntax.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "077"
    question: "What does the QUERY_TAG session parameter allow you to do for monitoring purposes?"
    their_options:
      option A: "Automatically categorize queries by their SQL type (SELECT, INSERT, etc.)"
      option B: "Tag queries with a custom string that appears in QUERY_HISTORY, enabling cost attribution and tracking"
      option C: "Assign priority levels to queries"
      option D: "Route queries to specific warehouse clusters"
    correct Answer: "B"
    explanation: >
      B is correct because QUERY_TAG is a session parameter that allows users to attach a
      custom string to queries. This tag appears in QUERY_HISTORY and can be used for cost
      attribution, tracking by team, project, or application. A is wrong because SQL type
      categorization is automatic. C is wrong because Snowflake does not have query priority
      levels. D is wrong because query routing is automatic in multi-cluster warehouses.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "078"
    question: "How would you set a query tag for all queries in the current session?"
    their_options:
      option A: "ALTER SESSION SET QUERY_TAG = 'team=analytics';"
      option B: "SET QUERY_TAG = 'team=analytics';"
      option C: "ALTER WAREHOUSE SET QUERY_TAG = 'team=analytics';"
      option D: "CREATE TAG 'team=analytics';"
    correct Answer: "A"
    explanation: >
      A is correct because ALTER SESSION SET QUERY_TAG = 'value' sets the tag for all
      subsequent queries in the current session. B is incomplete syntax (though SET can be
      used in some contexts). C is wrong because QUERY_TAG is a session parameter, not a
      warehouse parameter. D is wrong because CREATE TAG is for Snowflake object tags, which
      are different from QUERY_TAG.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "079"
    question: "In the context of warehouse monitoring, what is the significance of the BYTES_SCANNED column in QUERY_HISTORY?"
    their_options:
      option A: "It shows the total data stored in the tables queried"
      option B: "It indicates how much data the query physically scanned, useful for identifying inefficient queries"
      option C: "It shows the amount of data transferred to the client"
      option D: "It represents the warehouse cache size"
    correct Answer: "B"
    explanation: >
      B is correct because BYTES_SCANNED shows the amount of data physically scanned during
      query execution. High values relative to the result set indicate potential optimization
      opportunities (e.g., missing clustering, partition pruning issues). A is wrong because
      it shows scanned data, not total stored data. C is wrong because client transfer is
      tracked separately. D is wrong because it is not related to cache size.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "080"
    question: "What monitoring metric would help you decide between scaling UP (larger warehouse) vs scaling OUT (more clusters)?"
    their_options:
      option A: "If individual queries are slow â†’ scale UP; if many concurrent queries are queuing â†’ scale OUT"
      option B: "Always scale UP first; only scale OUT if UP doesn't work"
      option C: "Always scale OUT first; it's always cheaper"
      option D: "The metrics are the same for both decisions"
    correct Answer: "A"
    explanation: >
      A is correct. This is a fundamental monitoring decision. If monitoring shows individual
      queries have high execution times, large data spillage, or high BYTES_SCANNED, scaling
      UP (larger warehouse) provides more compute per query. If monitoring shows high
      AVG_QUEUED_LOAD with many concurrent queries, scaling OUT (multi-cluster) distributes
      load across clusters. B and C are wrong because neither approach is universally first.
      D is wrong because the metrics differ for each scenario.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "081"
    question: "Which ACCOUNT_USAGE view tracks serverless feature credit consumption such as Snowpipe and automatic clustering?"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY"
      option B: "SERVERLESS_TASK_HISTORY"
      option C: "METERING_DAILY_HISTORY"
      option D: "PIPE_USAGE_HISTORY"
    correct Answer: "C"
    explanation: >
      C is correct because METERING_DAILY_HISTORY provides a unified view of credit
      consumption across all services including serverless features like Snowpipe, automatic
      clustering, materialized views, and search optimization. A only covers warehouse
      compute. B is not a standard view. D is specific to pipe operations, not a broad
      metering view.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "082"
    question: "How can you monitor credit usage by serverless features separately from warehouse compute?"
    their_options:
      option A: "They cannot be separated"
      option B: "Use METERING_HISTORY view which has a SERVICE_TYPE column distinguishing warehouse compute from serverless features"
      option C: "Use separate accounts for serverless and warehouse workloads"
      option D: "Use resource monitors which automatically separate the two"
    correct Answer: "B"
    explanation: >
      B is correct because the METERING_HISTORY views include a SERVICE_TYPE column that
      identifies the type of service (WAREHOUSE_METERING, PIPE, AUTO_CLUSTERING,
      MATERIALIZED_VIEW_MAINTENANCE, etc.), allowing you to separate compute from serverless.
      A is wrong because they can be separated. C is extreme and unnecessary. D is wrong
      because resource monitors only track warehouse credits, not serverless features.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "083"
    question: "A warehouse is configured with AUTO_SUSPEND = 300 and AUTO_RESUME = TRUE. The warehouse suspended at 10:00 AM. At 10:04 AM, a user runs a query. What happens?"
    their_options:
      option A: "The query fails because the warehouse is suspended"
      option B: "The warehouse automatically resumes, the query may wait briefly during provisioning, then executes"
      option C: "The query is queued indefinitely until someone manually resumes the warehouse"
      option D: "The warehouse resumes but the query is dropped"
    correct Answer: "B"
    explanation: >
      B is correct because with AUTO_RESUME = TRUE, the warehouse automatically resumes when
      a query is submitted. The query may experience a brief QUEUED_PROVISIONING_TIME while
      the warehouse starts, then executes normally. A is wrong because AUTO_RESUME prevents
      query failure. C is wrong because the resume is automatic. D is wrong because the query
      is not dropped.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "084"
    question: "Which command shows the current resource monitors and their credit usage?"
    their_options:
      option A: "SHOW RESOURCE MONITORS;"
      option B: "LIST RESOURCE MONITORS;"
      option C: "DESCRIBE RESOURCE MONITORS;"
      option D: "SELECT * FROM RESOURCE_MONITORS;"
    correct Answer: "A"
    explanation: >
      A is correct because SHOW RESOURCE MONITORS displays all resource monitors with their
      current credit quota, credits used, remaining credits, frequency, and trigger settings.
      B, C, and D are not valid Snowflake commands for this purpose.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "085"
    question: "Can resource monitors track credits consumed by Snowflake Serverless features like Snowpipe?"
    their_options:
      option A: "Yes, resource monitors track all credit consumption"
      option B: "No, resource monitors only track virtual warehouse credit consumption"
      option C: "Yes, but only if the serverless feature is explicitly assigned to the monitor"
      option D: "Yes, at the account level only"
    correct Answer: "B"
    explanation: >
      B is correct because resource monitors only track and control credit consumption by
      virtual warehouses. They do not monitor serverless feature credits (Snowpipe, auto
      clustering, materialized view maintenance, etc.). A is wrong because they are limited
      to warehouses. C and D are wrong because there is no way to assign serverless features
      to resource monitors.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "086"
    question: "What is the maximum number of triggers you can set on a single resource monitor?"
    their_options:
      option A: "1"
      option B: "3"
      option C: "5"
      option D: "There is no hard limit on the number of triggers per resource monitor"
    correct Answer: "D"
    explanation: >
      D is correct because there is no specified maximum number of triggers on a resource
      monitor. You can set multiple triggers at different percentage thresholds with different
      actions (NOTIFY, SUSPEND, SUSPEND_IMMEDIATE). A, B, and C all specify arbitrary limits
      that do not exist.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "087"
    question: "A resource monitor has triggers at 75% (NOTIFY), 90% (NOTIFY), and 100% (SUSPEND). The monitor reaches 95% of its credit quota. Which triggers have fired?"
    their_options:
      option A: "Only the 75% trigger"
      option B: "The 75% and 90% triggers"
      option C: "All three triggers"
      option D: "Only the 90% trigger"
    correct Answer: "B"
    explanation: >
      B is correct because at 95% credit usage, the 75% NOTIFY trigger and the 90% NOTIFY
      trigger have both fired. The 100% SUSPEND trigger has not yet been reached. A is wrong
      because the 90% trigger has also fired. C is wrong because 100% has not been reached.
      D is wrong because the 75% trigger also fired.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "088"
    question: "After a resource monitor suspends a warehouse due to reaching 100% of the credit quota, how can the warehouse be restarted?"
    their_options:
      option A: "It automatically restarts when new credits are available next billing period"
      option B: "The credit quota must be increased, or the monitor must be modified or removed, and then the warehouse must be manually resumed"
      option C: "Only Snowflake Support can restart it"
      option D: "It restarts automatically after 1 hour"
    correct Answer: "B"
    explanation: >
      B is correct because after a resource monitor suspends a warehouse, an administrator
      must either increase the CREDIT_QUOTA, modify the triggers, remove the resource monitor,
      or wait for the quota to reset (if FREQUENCY is not NEVER). The warehouse must then be
      manually resumed. A is wrong because it does not automatically restart even when the
      quota resets. C is wrong because Snowflake Support intervention is not required. D is
      wrong because there is no automatic 1-hour restart.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "089"
    question: "Which column in QUERY_HISTORY indicates whether the query result was served from the result cache?"
    their_options:
      option A: "CACHE_HIT"
      option B: "RESULT_CACHE_USED"
      option C: "QUERY_TYPE with value 'CACHED'"
      option D: "BYTES_SCANNED = 0 and EXECUTION_TIME is very low"
    correct Answer: "D"
    explanation: >
      D is correct. While there is no explicit CACHE_HIT column, a query served entirely from
      the result cache will show BYTES_SCANNED = 0 and very low EXECUTION_TIME (near 0ms)
      because no warehouse resources were used. A and B are not actual column names in
      QUERY_HISTORY. C is incorrect; QUERY_TYPE does not have a CACHED value.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "090"
    question: "In Snowsight, what information does the warehouse activity graph display?"
    their_options:
      option A: "Only the number of queries per minute"
      option B: "Credit consumption over time, warehouse status, and query load"
      option C: "Only the warehouse size changes over time"
      option D: "Network bandwidth usage by the warehouse"
    correct Answer: "B"
    explanation: >
      B is correct because the Snowsight warehouse activity graph provides a visual overview
      of credit consumption over time, warehouse operational status (running/suspended), and
      query load metrics. A is too limited. C only covers one aspect. D is not displayed in
      the warehouse activity graph.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst

  - Question No: "091"
    question: "What is the recommended approach to monitor credit usage across multiple Snowflake accounts in an organization?"
    their_options:
      option A: "Query WAREHOUSE_METERING_HISTORY in each account separately"
      option B: "Use the SNOWFLAKE.ORGANIZATION_USAGE schema from the organization account"
      option C: "Contact Snowflake Support for consolidated billing reports"
      option D: "Export data from each account and combine manually"
    correct Answer: "B"
    explanation: >
      B is correct because the ORGANIZATION_USAGE schema (available in the organization
      account) provides consolidated usage data across all accounts in the organization.
      A is inefficient and requires access to each account. C is unnecessary because
      self-service tools exist. D is manual and error-prone.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "092"
    question: "Which column in WAREHOUSE_METERING_HISTORY indicates the start time of the metering interval?"
    their_options:
      option A: "TIMESTAMP"
      option B: "START_TIME"
      option C: "METERING_START"
      option D: "INTERVAL_START"
    correct Answer: "B"
    explanation: >
      B is correct because START_TIME is the column name that indicates the beginning of the
      metering interval in WAREHOUSE_METERING_HISTORY. A, C, and D are not actual column names
      in this view.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "093"
    question: "You notice that CREDITS_USED_CLOUD_SERVICES is unusually high for a warehouse. What could be the cause?"
    their_options:
      option A: "The warehouse is running too many large queries"
      option B: "Heavy metadata operations, query parsing, SHOW/DESCRIBE commands, or access control checks"
      option C: "The warehouse size is too small"
      option D: "The warehouse is in a different region"
    correct Answer: "B"
    explanation: >
      B is correct because cloud services credits cover operations like metadata queries,
      query compilation and optimization, SHOW/DESCRIBE commands, and access control checks.
      High cloud services usage often indicates heavy metadata-intensive workloads. A is wrong
      because large queries primarily consume compute credits. C is wrong because warehouse
      size does not directly affect cloud services credits. D is wrong because region does not
      impact cloud services credit consumption.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "094"
    question: "How often is the WAREHOUSE_LOAD_HISTORY data aggregated?"
    their_options:
      option A: "Every second"
      option B: "Every minute"
      option C: "Every 5 minutes"
      option D: "Every hour"
    correct Answer: "C"
    explanation: >
      C is correct because WAREHOUSE_LOAD_HISTORY data is aggregated in 5-minute intervals.
      Each row represents a 5-minute window showing the average and peak load metrics. A and
      B are too granular. D is too coarse; the interval is 5 minutes.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "095"
    question: "What is the purpose of the SYSTEM$ABORT_ALL_QUERIES function?"
    their_options:
      option A: "Abort all queries across all warehouses in the account"
      option B: "Abort all queries currently running or queued on a specific warehouse"
      option C: "Abort all queries submitted by a specific user"
      option D: "Abort all queries that have exceeded STATEMENT_TIMEOUT_IN_SECONDS"
    correct Answer: "B"
    explanation: >
      B is correct because SYSTEM$ABORT_ALL_QUERIES aborts all active and queued queries on
      the specified warehouse. A is wrong because it targets a specific warehouse. C is wrong
      because it does not filter by user. D is wrong because timeout handling is automatic and
      separate.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "096"
    question: "Which parameter controls the maximum number of concurrent queries that can be queued for a warehouse?"
    their_options:
      option A: "MAX_CONCURRENCY_LEVEL"
      option B: "STATEMENT_QUEUED_TIMEOUT_IN_SECONDS"
      option C: "MAX_QUEUED_QUERIES"
      option D: "CONCURRENT_QUERY_LIMIT"
    correct Answer: "B"
    explanation: >
      B is correct because STATEMENT_QUEUED_TIMEOUT_IN_SECONDS controls how long a query
      can remain in the queue before being cancelled. While it doesn't directly limit the
      number of queued queries, it effectively manages queue buildup. A (MAX_CONCURRENCY_LEVEL)
      controls the number of concurrent queries that can run, not queued. C and D are not
      valid Snowflake parameters.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "097"
    question: "What does a STATEMENT_QUEUED_TIMEOUT_IN_SECONDS value of 0 mean?"
    their_options:
      option A: "Queries are never queued; they fail immediately if the warehouse is busy"
      option B: "Queries can be queued indefinitely (no timeout)"
      option C: "The parameter is disabled"
      option D: "Queries are queued for a default of 60 seconds"
    correct Answer: "B"
    explanation: >
      B is correct because setting STATEMENT_QUEUED_TIMEOUT_IN_SECONDS to 0 means there is
      no timeout limit, and queries can remain in the queue indefinitely until resources become
      available. A is wrong because 0 means no timeout, not immediate failure. C is partially
      correct in spirit but technically means no limit. D is wrong because there is no default
      fallback when set to 0.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "098"
    question: "A company has set up a resource monitor at the account level with CREDIT_QUOTA = 5000 and FREQUENCY = MONTHLY. They also have a warehouse-level monitor on WH_ETL with CREDIT_QUOTA = 1000. WH_ETL uses 1000 credits while total account usage is 3000. What happens?"
    their_options:
      option A: "Only the warehouse-level monitor triggers"
      option B: "Only the account-level monitor triggers"
      option C: "Both monitors trigger independently based on their own thresholds"
      option D: "The warehouse-level monitor overrides the account-level monitor"
    correct Answer: "A"
    explanation: >
      A is correct. The warehouse-level monitor for WH_ETL triggers when WH_ETL reaches its
      1000-credit quota. The account-level monitor tracks the total (3000/5000 = 60%), which
      has not yet reached any trigger thresholds. Both monitors operate independently, but in
      this scenario only the warehouse-level monitor has been triggered. C would be correct
      if the account-level monitor also had triggers at â‰¤60%, but the question implies standard
      triggers which typically start higher.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "099"
    question: "How can you view the history of warehouse size changes (resizing events)?"
    their_options:
      option A: "Query WAREHOUSE_EVENTS_HISTORY and filter for RESIZE events"
      option B: "Query WAREHOUSE_METERING_HISTORY and look for credit changes"
      option C: "Use SHOW WAREHOUSES HISTORY"
      option D: "Query LOGIN_HISTORY for ALTER WAREHOUSE events"
    correct Answer: "A"
    explanation: >
      A is correct because WAREHOUSE_EVENTS_HISTORY captures warehouse lifecycle events
      including resize operations. B might show credit changes but does not explicitly show
      resize events. C is not valid Snowflake syntax. D is wrong because LOGIN_HISTORY
      tracks login events, not warehouse changes.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "100"
    question: "A warehouse has SCALING_POLICY set to STANDARD in a multi-cluster configuration. When does a new cluster start?"
    their_options:
      option A: "When any single query is queued"
      option B: "When the system detects that queries are being queued or expected to be queued based on load"
      option C: "Only when the AVG_QUEUED_LOAD exceeds 10"
      option D: "Only when manually triggered by an administrator"
    correct Answer: "B"
    explanation: >
      B is correct because with STANDARD scaling policy, Snowflake starts additional clusters
      when it detects that queries are being queued or are expected to be queued, attempting
      to minimize queuing. A is too aggressiveâ€”one queued query may not trigger immediate
      scale-out. C specifies an arbitrary threshold that does not exist. D describes manual
      scaling, not auto-scale.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "101"
    question: "What is the difference between STANDARD and ECONOMY scaling policies for multi-cluster warehouses in terms of monitoring?"
    their_options:
      option A: "STANDARD is more aggressive in adding clusters; ECONOMY waits longer and conserves credits at the cost of some queuing"
      option B: "STANDARD and ECONOMY behave identically"
      option C: "ECONOMY adds clusters faster than STANDARD"
      option D: "STANDARD only works with Enterprise edition"
    correct Answer: "A"
    explanation: >
      A is correct. STANDARD scaling policy minimizes queuing by adding clusters more
      aggressively when load increases. ECONOMY conserves credits by waiting until the
      existing clusters are fully loaded before adding new ones, which may result in some
      query queuing. B is wrong because they behave differently. C reverses the behavior.
      D is wrong because both policies are available with multi-cluster warehouses in
      Enterprise edition and above.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "102"
    question: "Which query identifies warehouses that have been running but idle (no queries) for an extended period?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME, SUM(CREDITS_USED) as TOTAL_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
        HAVING SUM(CREDITS_USED) > 0;
      option B: >
        SELECT wm.WAREHOUSE_NAME, SUM(wm.CREDITS_USED) as CREDITS,
        COUNT(DISTINCT qh.QUERY_ID) as QUERY_COUNT
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY wm
        LEFT JOIN SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY qh
        ON wm.WAREHOUSE_NAME = qh.WAREHOUSE_NAME
        AND qh.START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        WHERE wm.START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        GROUP BY wm.WAREHOUSE_NAME
        HAVING QUERY_COUNT = 0 AND CREDITS > 0;
      option C: "SHOW IDLE WAREHOUSES;"
      option D: "SELECT * FROM WAREHOUSE_STATUS WHERE STATE = 'IDLE';"
    correct Answer: "B"
    explanation: >
      B is correct because it joins metering history with query history to find warehouses
      that consumed credits (were running) but had zero queries. This identifies warehouses
      that were left running with no workload. A only shows credit consumption but does not
      check for query activity. C is not valid syntax. D is not a valid view or command.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "103"
    question: "What is the SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY END_TIME column?"
    their_options:
      option A: "The time the warehouse was dropped"
      option B: "The end of the metering interval (typically 1 hour after START_TIME)"
      option C: "The time the warehouse was suspended"
      option D: "The end of the billing cycle"
    correct Answer: "B"
    explanation: >
      B is correct because END_TIME represents the end of the metering interval, which is
      typically 1 hour after the START_TIME. Each row covers a 1-hour metering window.
      A is wrong because warehouse drops are separate events. C is wrong because suspension
      is a different event. D is wrong because the billing cycle is a broader concept.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "104"
    question: "Which Snowflake feature allows you to set up automated alerts based on warehouse credit consumption without using resource monitors?"
    their_options:
      option A: "Snowflake Alerts (using CREATE ALERT)"
      option B: "Snowflake Tasks only"
      option C: "Snowflake Streams"
      option D: "There is no alternative to resource monitors"
    correct Answer: "A"
    explanation: >
      A is correct because Snowflake Alerts (CREATE ALERT) allow you to define conditions
      based on SQL queries and trigger notifications when conditions are met. You can create
      alerts that query WAREHOUSE_METERING_HISTORY and send notifications based on credit
      thresholds. B (Tasks) can run queries but lack built-in alerting. C (Streams) track
      data changes, not credit consumption. D is wrong because alerts provide an alternative.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "105"
    question: "What happens when you run ALTER WAREHOUSE my_wh SUSPEND?"
    their_options:
      option A: "The warehouse is immediately suspended and all running queries are cancelled"
      option B: "Currently running queries are allowed to complete, then the warehouse is suspended"
      option C: "The warehouse enters a 'pending suspend' state for 60 seconds"
      option D: "The command fails if queries are currently running"
    correct Answer: "B"
    explanation: >
      B is correct because ALTER WAREHOUSE ... SUSPEND allows currently running queries to
      complete before suspending the warehouse. New queries are not accepted. A describes
      forced/immediate behavior. C is wrong because there is no pending state. D is wrong
      because the command succeeds even with running queries.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "106"
    question: "What is the difference between ALTER WAREHOUSE SUSPEND and ALTER WAREHOUSE SUSPEND IMMEDIATE (if available)?"
    their_options:
      option A: "There is no difference"
      option B: "SUSPEND waits for running queries to complete; resource monitors with SUSPEND_IMMEDIATE cancel running queries"
      option C: "SUSPEND IMMEDIATE is not a valid command"
      option D: "SUSPEND IMMEDIATE only suspends after a 5-minute delay"
    correct Answer: "B"
    explanation: >
      B is correct. The standard ALTER WAREHOUSE SUSPEND waits for running queries to finish.
      The SUSPEND_IMMEDIATE action in resource monitors cancels running queries immediately.
      Note that SUSPEND_IMMEDIATE is primarily a resource monitor trigger action rather than
      a standalone ALTER WAREHOUSE command. A is wrong because they behave differently. D is
      wrong because there is no delay with SUSPEND_IMMEDIATE.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "107"
    question: "You are tasked with reducing warehouse costs by 30%. Which monitoring data should you analyze FIRST? (Select TWO)"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY to identify highest-cost warehouses"
      option B: "QUERY_HISTORY to find inefficient or unnecessary queries"
      option C: "STORAGE_USAGE to reduce data volume"
      option D: "LOGIN_HISTORY to reduce user access"
      option E: "DATA_TRANSFER_HISTORY to optimize transfers"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. To reduce warehouse costs, you need to first identify which
      warehouses consume the most credits (A) and then drill into which queries on those
      warehouses are the most expensive or unnecessary (B). C addresses storage costs, not
      compute. D reducing user access is not a direct cost optimization. E targets transfer
      costs, not warehouse compute.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "108"
    question: "What column in QUERY_HISTORY shows the warehouse size at the time the query ran?"
    their_options:
      option A: "WAREHOUSE_TYPE"
      option B: "WAREHOUSE_SIZE"
      option C: "CLUSTER_SIZE"
      option D: "COMPUTE_SIZE"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_SIZE in QUERY_HISTORY records the size of the warehouse
      (e.g., X-Small, Small, Medium, etc.) at the time the query executed. A (WAREHOUSE_TYPE)
      shows whether it's STANDARD or SNOWPARK_OPTIMIZED. C and D are not actual column names
      in QUERY_HISTORY.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "109"
    question: "How many credits per hour does an X-Small warehouse consume?"
    their_options:
      option A: "0.5 credits"
      option B: "1 credit"
      option C: "2 credits"
      option D: "4 credits"
    correct Answer: "B"
    explanation: >
      B is correct because an X-Small warehouse consumes 1 credit per hour. Each step up in
      size doubles the credits: Small = 2, Medium = 4, Large = 8, etc. A (0.5) is not correct
      for any standard size. C is for Small. D is for Medium.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst, Architect

  - Question No: "110"
    question: "A Medium warehouse runs for 2 hours and 30 minutes. How many credits are consumed?"
    their_options:
      option A: "8 credits"
      option B: "10 credits"
      option C: "12 credits"
      option D: "4 credits"
    correct Answer: "B"
    explanation: >
      B is correct. A Medium warehouse uses 4 credits per hour. 2.5 hours Ã— 4 credits/hour
      = 10 credits. A (8) would be 2 hours. C (12) would be 3 hours. D (4) would be 1 hour.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "111"
    question: "A 3-cluster Large warehouse runs for 1 hour. How many credits are consumed?"
    their_options:
      option A: "8 credits"
      option B: "16 credits"
      option C: "24 credits"
      option D: "32 credits"
    correct Answer: "C"
    explanation: >
      C is correct. A Large warehouse uses 8 credits per hour per cluster. With 3 clusters
      running, the total is 3 Ã— 8 = 24 credits for 1 hour. A is for 1 cluster. B is for
      2 clusters. D is for 4 clusters.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "112"
    question: "Which Snowsight page shows a history of all queries executed across all warehouses?"
    their_options:
      option A: "Admin > Warehouses"
      option B: "Activity > Query History"
      option C: "Data > Query Log"
      option D: "Monitoring > All Queries"
    correct Answer: "B"
    explanation: >
      B is correct because Snowsight's Activity > Query History page provides a comprehensive
      view of all queries executed across all warehouses, with filtering and sorting options.
      A shows warehouse details but not full query history. C and D are not valid Snowsight
      pages.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst

  - Question No: "113"
    question: "What is the purpose of the EXPLAIN command in Snowflake for warehouse monitoring?"
    their_options:
      option A: "It provides the estimated execution plan for a query without running it"
      option B: "It shows the actual execution statistics after a query completes"
      option C: "It explains the warehouse configuration"
      option D: "It provides cost estimates in credits for a query"
    correct Answer: "A"
    explanation: >
      A is correct because EXPLAIN generates the estimated execution plan showing how Snowflake
      would process the query, including which operations would be performed, without actually
      executing the query. B describes Query Profile (post-execution). C is wrong; EXPLAIN is
      for queries, not warehouses. D is wrong because EXPLAIN does not provide credit estimates.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "114"
    question: "In the Query Profile, what does the 'Pruning' statistic indicate?"
    their_options:
      option A: "The number of rows deleted by the query"
      option B: "The percentage of micro-partitions eliminated (skipped) during table scan due to query predicates"
      option C: "The number of queries removed from the queue"
      option D: "The amount of cache data cleared"
    correct Answer: "B"
    explanation: >
      B is correct because pruning in Query Profile shows how many micro-partitions were
      eliminated (not scanned) based on query predicates and table metadata, versus total
      partitions. High pruning is desirable as it reduces data scanned. A is about DML
      operations. C is not related. D is not related.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "115"
    question: "A Query Profile shows that 500 out of 10,000 partitions were scanned. What is the pruning ratio?"
    their_options:
      option A: "5% scanned, 95% pruned"
      option B: "50% scanned, 50% pruned"
      option C: "95% scanned, 5% pruned"
      option D: "500% pruning efficiency"
    correct Answer: "A"
    explanation: >
      A is correct. 500 scanned out of 10,000 total means 500/10,000 = 5% was scanned, and
      the remaining 9,500/10,000 = 95% was pruned (skipped). This is excellent pruning
      efficiency. B, C, and D are mathematically incorrect.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "116"
    question: "What does it mean when the Query Profile shows 'Exploding Joins' as a problem?"
    their_options:
      option A: "Too many JOIN conditions in the query"
      option B: "The join produces significantly more rows than the input tables due to many-to-many relationships"
      option C: "The JOIN keyword is used incorrectly"
      option D: "The warehouse ran out of memory during the join"
    correct Answer: "B"
    explanation: >
      B is correct because 'Exploding Joins' in Query Profile indicates that a join operation
      produces a Cartesian-product-like result, where the output rows vastly exceed input rows
      due to many-to-many matching conditions. A is wrong because the issue is about data
      relationships, not syntax. C is wrong because it is not a syntax issue. D may be a
      consequence but is not what the indicator directly means.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "117"
    question: "Which QUERY_HISTORY column shows the type of query execution status?"
    their_options:
      option A: "QUERY_STATUS"
      option B: "EXECUTION_STATUS"
      option C: "STATUS"
      option D: "QUERY_STATE"
    correct Answer: "B"
    explanation: >
      B is correct because EXECUTION_STATUS in QUERY_HISTORY shows whether the query
      succeeded, failed, or is in another state (RUNNING, QUEUED, etc.). A, C, and D are
      not the correct column names in QUERY_HISTORY.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "118"
    question: "You want to set up a weekly report on warehouse utilization. Which approach allows automated delivery?"
    their_options:
      option A: "Create a Snowflake Task that runs a stored procedure to query monitoring views and send results via email notification integration"
      option B: "Manually run SHOW WAREHOUSES every Monday"
      option C: "Set up a resource monitor with FREQUENCY = WEEKLY"
      option D: "Use the COPY INTO command to export monitoring data weekly"
    correct Answer: "A"
    explanation: >
      A is correct because Snowflake Tasks combined with stored procedures and notification
      integrations (e.g., email) can automate weekly monitoring reports. B is manual. C
      resource monitors alert on thresholds, not deliver utilization reports. D could export
      data but lacks automated delivery and analysis.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "119"
    question: "What is the key monitoring consideration when using Snowpark-optimized warehouses?"
    their_options:
      option A: "They consume the same credits as standard warehouses"
      option B: "They consume more credits per hour than standard warehouses of the same size due to additional memory"
      option C: "They do not appear in WAREHOUSE_METERING_HISTORY"
      option D: "They cannot be monitored with resource monitors"
    correct Answer: "B"
    explanation: >
      B is correct because Snowpark-optimized warehouses have more memory per node and
      therefore consume more credits per hour compared to standard warehouses of the same
      T-shirt size. This is an important cost monitoring consideration. A is wrong because
      the credit rate is higher. C is wrong because they do appear in metering views. D is
      wrong because resource monitors work with all warehouse types.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "120"
    question: "Which TWO query performance issues can be identified through BYTES_SPILLED_TO_LOCAL_STORAGE and BYTES_SPILLED_TO_REMOTE_STORAGE? (Select TWO)"
    their_options:
      option A: "The warehouse does not have enough memory for the query workload"
      option B: "The query would benefit from a larger warehouse size"
      option C: "The network bandwidth is insufficient"
      option D: "The data is not properly encrypted"
      option E: "The query is too simple for the warehouse"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. Data spillage indicates insufficient memory in the warehouse. This
      means the warehouse lacks resources (A) and the query would benefit from a larger
      warehouse with more memory (B). C is wrong because spillage is about memory, not
      network. D is irrelevant. E is wrong because simple queries would not cause spillage.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "121"
    question: "What is the relationship between TOTAL_ELAPSED_TIME and its component times in QUERY_HISTORY?"
    their_options:
      option A: "TOTAL_ELAPSED_TIME = COMPILATION_TIME + EXECUTION_TIME"
      option B: "TOTAL_ELAPSED_TIME = QUEUED_PROVISIONING_TIME + QUEUED_OVERLOAD_TIME + QUEUED_BLOCKED_TIME + COMPILATION_TIME + EXECUTION_TIME"
      option C: "TOTAL_ELAPSED_TIME is always equal to EXECUTION_TIME"
      option D: "TOTAL_ELAPSED_TIME = EXECUTION_TIME Ã— 2"
    correct Answer: "B"
    explanation: >
      B is correct because TOTAL_ELAPSED_TIME is the sum of all phases: queuing times
      (provisioning, overload, blocked), compilation time, and execution time. A is incomplete
      because it excludes queuing times. C is wrong because total time includes more than
      execution. D is an arbitrary formula with no basis.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "122"
    question: "What does the 'Running' column in SHOW WAREHOUSES display for a multi-cluster warehouse?"
    their_options:
      option A: "The number of queries currently running"
      option B: "The number of clusters currently active/running"
      option C: "Whether the warehouse is in Running state (boolean)"
      option D: "The total runtime in hours"
    correct Answer: "B"
    explanation: >
      B is correct because for multi-cluster warehouses, the 'running' column in SHOW
      WAREHOUSES shows the number of clusters currently active. For single-cluster warehouses,
      it shows 0 (suspended) or 1 (running). A is about query count, not cluster count.
      C is a simplified interpretation. D is not what this column shows.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "123"
    question: "What does the 'Queued' column in SHOW WAREHOUSES display?"
    their_options:
      option A: "The number of queries currently queued waiting for warehouse resources"
      option B: "The number of warehouses in a queued state"
      option C: "The number of pending cluster scale-out events"
      option D: "The total number of queries ever queued"
    correct Answer: "C"
    explanation: >
      C is correct because for multi-cluster warehouses, the 'queued' column shows the number
      of cluster provisioning events that are pending (clusters being started but not yet
      available). A describes the query queue, which is different from cluster queue. B is
      wrong. D is wrong because it shows current, not historical.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "124"
    question: "Which approach is recommended for setting up cost allocation tags on warehouses?"
    their_options:
      option A: "Use Snowflake object tags (ALTER WAREHOUSE SET TAG) to tag warehouses by department or project"
      option B: "Include cost center information in the warehouse name"
      option C: "Create separate Snowflake accounts per department"
      option D: "Use QUERY_TAG exclusively for all cost allocation"
    correct Answer: "A"
    explanation: >
      A is correct because Snowflake's object tagging feature (using ALTER WAREHOUSE SET TAG)
      allows you to assign metadata tags (e.g., department, cost_center, project) to warehouses
      for organized cost allocation and reporting. B is a workaround but not best practice.
      C is extreme and adds management overhead. D is useful at the query level but does not
      tag the warehouse itself.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "125"
    question: "What happens to monitoring data when a warehouse is dropped?"
    their_options:
      option A: "All historical data for the warehouse is immediately deleted"
      option B: "Historical data in ACCOUNT_USAGE views is retained for up to 365 days; INFORMATION_SCHEMA data for up to 14 days"
      option C: "Historical data is moved to a separate archive"
      option D: "The data is retained indefinitely"
    correct Answer: "B"
    explanation: >
      B is correct because dropping a warehouse does not delete its historical monitoring data
      from ACCOUNT_USAGE (retained up to 365 days) or INFORMATION_SCHEMA (up to 14 days).
      The data remains queryable for its standard retention period. A is wrong because data is
      not immediately deleted. C is wrong because there is no separate archive. D is wrong
      because retention has limits.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "126"
    question: "How can you monitor the effectiveness of auto-scaling in a multi-cluster warehouse?"
    their_options:
      option A: "Only by checking the monthly bill"
      option B: "Query WAREHOUSE_EVENTS_HISTORY for cluster start/stop events and correlate with WAREHOUSE_LOAD_HISTORY"
      option C: "Check SHOW WAREHOUSES once per day"
      option D: "It cannot be monitored"
    correct Answer: "B"
    explanation: >
      B is correct because correlating cluster scale events from WAREHOUSE_EVENTS_HISTORY with
      load metrics from WAREHOUSE_LOAD_HISTORY gives a comprehensive picture of when and why
      clusters scaled, and whether the scaling was effective in reducing queue times. A is
      reactive and lacks detail. C is a single snapshot, insufficient for analysis. D is wrong
      because multiple views enable monitoring.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "127"
    question: "Which SQL retrieves the top 10 warehouses by credit consumption in the last month?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME, SUM(CREDITS_USED) AS TOTAL_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('month', -1, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
        ORDER BY TOTAL_CREDITS DESC
        LIMIT 10;
      option B: >
        SELECT TOP 10 WAREHOUSE_NAME FROM SHOW WAREHOUSES
        ORDER BY CREDITS DESC;
      option C: >
        SELECT WAREHOUSE_NAME, CREDITS_USED
        FROM INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY
        WHERE DATEDIFF('month', START_TIME, CURRENT_TIMESTAMP()) <= 1
        ORDER BY CREDITS_USED DESC LIMIT 10;
      option D: >
        SELECT WAREHOUSE_NAME, MAX(CREDITS_USED)
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        GROUP BY WAREHOUSE_NAME LIMIT 10;
    correct Answer: "A"
    explanation: >
      A is correct because it queries ACCOUNT_USAGE (which has 365-day retention), sums
      credits per warehouse for the last month, and returns the top 10. B is invalid SQL
      syntax. C uses INFORMATION_SCHEMA which only has 14 days and the syntax for calling
      it as a table function is different. D is wrong because QUERY_HISTORY does not have
      a CREDITS_USED column.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "128"
    question: "What is the granularity of data in WAREHOUSE_METERING_HISTORY?"
    their_options:
      option A: "Per minute"
      option B: "Per hour"
      option C: "Per day"
      option D: "Per query"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_METERING_HISTORY stores credit consumption data at an
      hourly granularity. Each row represents one hour of metering data for a specific
      warehouse. A is too fine. C is too coarse. D would be per-query, which is QUERY_HISTORY.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "129"
    question: "A data engineer wants to identify queries that could benefit from the Query Acceleration Service. Which system function should they use?"
    their_options:
      option A: "SYSTEM$ESTIMATE_QUERY_ACCELERATION"
      option B: "SYSTEM$CHECK_QUERY_PERFORMANCE"
      option C: "SYSTEM$QUERY_ACCELERATION_ELIGIBLE"
      option D: "SYSTEM$GET_QUERY_PLAN"
    correct Answer: "A"
    explanation: >
      A is correct because SYSTEM$ESTIMATE_QUERY_ACCELERATION evaluates a specific query (by
      query ID) and estimates how much it would benefit from the Query Acceleration Service.
      B, C, and D are not valid Snowflake system functions for this purpose.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "130"
    question: "What does the SYSTEM$ESTIMATE_QUERY_ACCELERATION function return?"
    their_options:
      option A: "Only a boolean indicating if the query is eligible"
      option B: "Estimated upper bound of improvement factor and eligible status for the query"
      option C: "The exact number of credits the acceleration would cost"
      option D: "A modified version of the query optimized for acceleration"
    correct Answer: "B"
    explanation: >
      B is correct because the function returns eligibility status and an estimated upper
      bound for the performance improvement factor. A is incomplete; it also provides an
      improvement estimate. C is wrong because exact credit costs are not provided. D is
      wrong because it does not modify the query.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "131"
    question: "How can you track credit consumption specifically for the Query Acceleration Service?"
    their_options:
      option A: "It is included in standard warehouse credits and cannot be separated"
      option B: "Query QUERY_ACCELERATION_HISTORY in ACCOUNT_USAGE"
      option C: "Check WAREHOUSE_METERING_HISTORY only"
      option D: "It is free and does not consume credits"
    correct Answer: "B"
    explanation: >
      B is correct because QUERY_ACCELERATION_HISTORY in the ACCOUNT_USAGE schema specifically
      tracks credit usage by the Query Acceleration Service. A is wrong because QAS credits
      are tracked separately. C is incomplete. D is wrong because QAS does consume additional
      credits.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "132"
    question: "Your organization has 50 warehouses. What is the most efficient way to get a quick overview of all warehouse states?"
    their_options:
      option A: "Query WAREHOUSE_METERING_HISTORY for each warehouse individually"
      option B: "Run SHOW WAREHOUSES; to see all warehouses and their current state in one command"
      option C: "Check each warehouse in Snowsight one at a time"
      option D: "Query INFORMATION_SCHEMA.WAREHOUSES"
    correct Answer: "B"
    explanation: >
      B is correct because SHOW WAREHOUSES returns all warehouses the current role can see
      with their state, size, auto_suspend, auto_resume, and other properties in one
      command. A is too granular for an overview. C is time-consuming. D is wrong because
      there is no INFORMATION_SCHEMA.WAREHOUSES table.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "133"
    question: "Which columns does SHOW WAREHOUSES return? (Select THREE)"
    their_options:
      option A: "name"
      option B: "state"
      option C: "size"
      option D: "credits_used_today"
      option E: "total_queries_run"
    correct Answer: "A, B, C"
    explanation: >
      A, B, and C are correct. SHOW WAREHOUSES returns columns including name, state
      (Started/Suspended), size (X-Small to 6X-Large), among others like auto_suspend,
      auto_resume, type, etc. D (credits_used_today) is not a column in SHOW WAREHOUSES.
      E (total_queries_run) is not a column in SHOW WAREHOUSES.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "134"
    question: "A warehouse is showing high COMPILATION_TIME for most queries. What is the most likely cause?"
    their_options:
      option A: "The warehouse is too small"
      option B: "The queries involve complex SQL with many joins, subqueries, or CTEs, or the cloud services layer is under heavy load"
      option C: "The data files are corrupted"
      option D: "The warehouse needs to be resized to a different type"
    correct Answer: "B"
    explanation: >
      B is correct because high COMPILATION_TIME is typically caused by complex SQL that takes
      longer for the optimizer to parse and plan, or by heavy cloud services layer load. Query
      compilation happens in the cloud services layer, not the warehouse compute layer. A is
      wrong because warehouse size does not affect compilation time. C is wrong because
      corruption would cause errors, not slow compilation. D is wrong because warehouse type
      does not impact compilation.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "135"
    question: "What is the significance of monitoring ROWS_PRODUCED in QUERY_HISTORY?"
    their_options:
      option A: "It shows how many rows were inserted into a table"
      option B: "It indicates the number of rows returned to the client, which can identify queries returning excessive data"
      option C: "It shows the total rows in the queried tables"
      option D: "It counts the number of times the query was executed"
    correct Answer: "B"
    explanation: >
      B is correct because ROWS_PRODUCED shows the number of rows in the query result set
      returned to the client. Monitoring this can identify queries returning unnecessarily
      large result sets, which impacts network transfer and client processing. A is wrong
      because DML row counts are separate. C is wrong because it does not show total table
      size. D is wrong because it is not an execution count.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "136"
    question: "Which view helps identify tables that are causing the most warehouse resource consumption?"
    their_options:
      option A: "TABLE_STORAGE_METRICS"
      option B: "ACCESS_HISTORY combined with QUERY_HISTORY"
      option C: "TABLE_METERING_HISTORY"
      option D: "WAREHOUSE_TABLE_USAGE"
    correct Answer: "B"
    explanation: >
      B is correct because ACCESS_HISTORY tracks which tables/columns were accessed by each
      query, and when combined with QUERY_HISTORY (which has execution times and warehouse
      info), you can identify tables driving the most resource consumption. A tracks storage,
      not compute. C is not a standard view. D is not a standard view.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "137"
    question: "How can you set up email notifications for resource monitor alerts?"
    their_options:
      option A: "Configure email addresses in the resource monitor CREATE statement"
      option B: "Account administrators must enable notifications in Snowsight under their user preferences"
      option C: "Create a notification integration and attach it to the resource monitor"
      option D: "Email notifications are not supported for resource monitors"
    correct Answer: "B"
    explanation: >
      B is correct because resource monitor notifications are sent to Account Administrators
      who have enabled email notifications in the Snowsight UI under their preferences. There
      is no way to specify email addresses in the resource monitor DDL itself. A is wrong
      because email addresses are not in the DDL. C describes notification integrations which
      are for other features like tasks and alerts, not resource monitors directly. D is wrong
      because email notifications are supported.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "138"
    question: "What is the impact of setting AUTO_SUSPEND to NULL?"
    their_options:
      option A: "The warehouse will never auto-suspend and will run continuously until manually suspended"
      option B: "The warehouse uses the default auto-suspend of 600 seconds"
      option C: "The warehouse immediately suspends"
      option D: "Auto-suspend is set to the minimum of 60 seconds"
    correct Answer: "A"
    explanation: >
      A is correct because setting AUTO_SUSPEND to NULL (or 0) disables auto-suspension. The
      warehouse will continue running and consuming credits until it is manually suspended.
      B is wrong because NULL overrides the default. C is wrong because NULL means never
      suspend, not immediate suspend. D is wrong because NULL does not set the minimum.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "139"
    question: "Which scenario would result in the HIGHEST unexpected credit consumption?"
    their_options:
      option A: "A small warehouse with AUTO_SUSPEND = 60 running intermittent queries"
      option B: "A 4X-Large warehouse with AUTO_SUSPEND = NULL left running over a weekend with no queries"
      option C: "A medium warehouse with AUTO_SUSPEND = 300 running batch jobs"
      option D: "An X-Small warehouse with AUTO_SUSPEND = 60 and no queries submitted"
    correct Answer: "B"
    explanation: >
      B is correct. A 4X-Large warehouse (128 credits/hour) with AUTO_SUSPEND disabled (NULL)
      running over a weekend (48+ hours) with no queries would consume 128 Ã— 48 = 6,144+
      credits while doing nothing. This is the highest unexpected cost scenario. A would have
      minimal cost due to small size and auto-suspend. C is expected usage. D would auto-suspend
      after 60 seconds of inactivity.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "140"
    question: "What does the WAREHOUSE_TYPE column in SHOW WAREHOUSES indicate?"
    their_options:
      option A: "Whether the warehouse is multi-cluster or single"
      option B: "The cloud provider hosting the warehouse"
      option C: "Whether the warehouse is STANDARD or SNOWPARK_OPTIMIZED"
      option D: "The edition of Snowflake (Standard, Enterprise, etc.)"
    correct Answer: "C"
    explanation: >
      C is correct because WAREHOUSE_TYPE indicates whether the warehouse is a STANDARD
      warehouse or a SNOWPARK_OPTIMIZED warehouse (which has more memory). A is wrong because
      multi-cluster is indicated by cluster settings. B is wrong because the cloud provider
      is an account property. D is wrong because edition is account-level.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "141"
    question: "A query shows QUEUED_OVERLOAD_TIME = 30000 milliseconds (30 seconds). What action should you consider?"
    their_options:
      option A: "Ignore it; 30 seconds is acceptable"
      option B: "Scale up the warehouse size or enable multi-cluster auto-scaling to handle concurrent load"
      option C: "Drop and recreate the warehouse"
      option D: "Change the warehouse type to SNOWPARK_OPTIMIZED"
    correct Answer: "B"
    explanation: >
      B is correct because 30 seconds of overload queuing means the warehouse lacks capacity
      for concurrent queries. Scaling up provides more resources per query, while multi-cluster
      auto-scaling distributes queries across additional clusters. A is wrong because 30
      seconds of unnecessary waiting is significant. C would not solve the capacity issue.
      D is wrong because SNOWPARK_OPTIMIZED is for memory-intensive UDF workloads, not
      concurrency.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "142"
    question: "Which privilege is required to view QUERY_HISTORY for queries executed by other users?"
    their_options:
      option A: "USAGE on the warehouse"
      option B: "MONITOR privilege on the warehouse or ACCOUNTADMIN role"
      option C: "OPERATE on the warehouse"
      option D: "Any user can see all query history"
    correct Answer: "B"
    explanation: >
      B is correct. By default, users can only see their own query history. To see other
      users' queries, you need the MONITOR privilege on the warehouse or the ACCOUNTADMIN
      role (or access to ACCOUNT_USAGE views via IMPORTED PRIVILEGES). A (USAGE) allows
      running queries but not monitoring others. C (OPERATE) allows suspend/resume. D is
      wrong because query history is role-restricted.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "143"
    question: "What is the maximum number of resource monitors that can be set at the account level?"
    their_options:
      option A: "1"
      option B: "5"
      option C: "10"
      option D: "Unlimited"
    correct Answer: "A"
    explanation: >
      A is correct because only one resource monitor can be set at the account level at any
      given time. This account-level monitor applies to all warehouses collectively. B, C,
      and D are wrong because the limit is strictly one account-level monitor.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "144"
    question: "How do you assign a resource monitor at the account level?"
    their_options:
      option A: "ALTER ACCOUNT SET RESOURCE_MONITOR = my_monitor;"
      option B: "CREATE RESOURCE MONITOR my_monitor FOR ACCOUNT;"
      option C: "GRANT RESOURCE MONITOR my_monitor TO ACCOUNT;"
      option D: "SET ACCOUNT RESOURCE_MONITOR = my_monitor;"
    correct Answer: "A"
    explanation: >
      A is correct because ALTER ACCOUNT SET RESOURCE_MONITOR = <monitor_name> assigns a
      resource monitor at the account level. Only ACCOUNTADMIN can execute this. B is wrong
      because FOR ACCOUNT is not part of the CREATE syntax. C is not valid syntax. D is not
      valid syntax.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "145"
    question: "A resource monitor with FREQUENCY = MONTHLY started on January 15. When does the credit quota reset?"
    their_options:
      option A: "On the 1st of each month"
      option B: "On the 15th of each month (same day as the start timestamp)"
      option C: "Every 30 days from the start date"
      option D: "It never resets within the same month"
    correct Answer: "B"
    explanation: >
      B is correct because the credit quota resets on the same day of each month as specified
      in the START_TIMESTAMP. If the monitor started on January 15, it resets on February 15,
      March 15, etc. A is wrong because it follows the START_TIMESTAMP, not the calendar month
      start. C is wrong because it aligns to the same calendar day, not exactly 30 days.
      D is wrong because it does reset monthly.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "146"
    question: "Which of the following can you see in Snowsight's Query History page? (Select THREE)"
    their_options:
      option A: "SQL text of the query"
      option B: "Duration of the query"
      option C: "Warehouse used"
      option D: "Credits consumed by that specific query"
      option E: "User who ran the query"
    correct Answer: "A, B, C"
    explanation: >
      A, B, and C are correct. Snowsight's Query History page displays the SQL text, duration,
      and warehouse name for each query, along with status and other details. D is wrong
      because credits are not shown per-query in the UI (credits are tracked at warehouse
      level). E is also visible in Snowsight query history, but the question asks to select
      THREE and A, B, C are the most directly displayed monitoring-relevant fields.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst

  - Question No: "147"
    question: "What is the purpose of the MAX_CONCURRENCY_LEVEL parameter?"
    their_options:
      option A: "It limits the maximum number of warehouses that can run simultaneously"
      option B: "It limits the maximum number of SQL statements that can be executed concurrently by a warehouse"
      option C: "It limits the number of users who can connect to a warehouse"
      option D: "It limits the number of clusters in a multi-cluster warehouse"
    correct Answer: "B"
    explanation: >
      B is correct because MAX_CONCURRENCY_LEVEL controls the maximum number of concurrent
      SQL statements (queries, DML, etc.) that a warehouse cluster can execute. Queries
      beyond this limit are queued. A is wrong because it applies to a single warehouse.
      C is wrong because it controls statement concurrency, not connections. D is wrong
      because cluster count is controlled by MIN/MAX_CLUSTER_COUNT.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "148"
    question: "What is the default value for MAX_CONCURRENCY_LEVEL?"
    their_options:
      option A: "4"
      option B: "8"
      option C: "16"
      option D: "The default is determined automatically by Snowflake based on warehouse size"
    correct Answer: "B"
    explanation: >
      B is correct because the default MAX_CONCURRENCY_LEVEL is 8. This means a warehouse
      cluster will execute up to 8 statements concurrently before queuing additional ones.
      A, C are incorrect values. D is wrong because the default is a fixed value of 8,
      not dynamically determined.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "149"
    question: "How does reducing MAX_CONCURRENCY_LEVEL from 8 to 4 affect warehouse behavior?"
    their_options:
      option A: "The warehouse processes fewer concurrent queries, giving each query more resources, but increases queuing"
      option B: "The warehouse becomes faster for all queries"
      option C: "The warehouse consumes fewer credits"
      option D: "The warehouse automatically scales down in size"
    correct Answer: "A"
    explanation: >
      A is correct because reducing concurrency means fewer queries share warehouse resources
      simultaneously, potentially improving individual query performance but increasing queue
      wait times for other queries. B is wrong because it is not universally faster; queued
      queries wait longer. C is wrong because credit consumption depends on runtime, not
      concurrency settings. D is wrong because concurrency settings do not change warehouse
      size.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "150"
    question: "Which ACCOUNT_USAGE view provides information about warehouse events including cluster scaling?"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY"
      option B: "WAREHOUSE_EVENTS_HISTORY"
      option C: "WAREHOUSE_LOAD_HISTORY"
      option D: "CLUSTER_SCALING_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_EVENTS_HISTORY captures all warehouse lifecycle events
      including cluster scaling (adding/removing clusters in multi-cluster mode), resizing,
      suspending, and resuming. A tracks credits. C tracks load metrics. D is not a real view.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "151"
    question: "A warehouse has been consistently using only 10% of its capacity. Which monitoring metrics confirm this? (Select TWO)"
    their_options:
      option A: "AVG_RUNNING is very low (close to 0) in WAREHOUSE_LOAD_HISTORY"
      option B: "CREDITS_USED is very high in WAREHOUSE_METERING_HISTORY"
      option C: "AVG_QUEUED_LOAD is consistently 0 in WAREHOUSE_LOAD_HISTORY"
      option D: "BYTES_SPILLED_TO_REMOTE_STORAGE is high in QUERY_HISTORY"
      option E: "EXECUTION_TIME is consistently high for all queries"
    correct Answer: "A, C"
    explanation: >
      A and C are correct. Low AVG_RUNNING (few queries executing at once) combined with zero
      AVG_QUEUED_LOAD (no queuing) indicates the warehouse is significantly underutilized and
      could likely be downsized. B (high credits) contradicts underutilization. D (high
      spillage) would suggest undersizing. E (high execution time) would suggest performance
      issues, not underutilization.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "152"
    question: "What is the correct syntax to modify a resource monitor's credit quota?"
    their_options:
      option A: "ALTER RESOURCE MONITOR my_monitor SET CREDIT_QUOTA = 2000;"
      option B: "UPDATE RESOURCE MONITOR my_monitor SET CREDIT_QUOTA = 2000;"
      option C: "MODIFY RESOURCE MONITOR my_monitor CREDIT_QUOTA = 2000;"
      option D: "ALTER MONITOR my_monitor SET CREDIT_QUOTA = 2000;"
    correct Answer: "A"
    explanation: >
      A is correct because ALTER RESOURCE MONITOR ... SET CREDIT_QUOTA is the valid syntax
      to modify the credit quota. B (UPDATE) is a DML command for data, not DDL. C (MODIFY)
      is not valid syntax. D is wrong because the object is RESOURCE MONITOR, not MONITOR.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "153"
    question: "How can you remove a resource monitor from a warehouse?"
    their_options:
      option A: "DROP RESOURCE MONITOR my_monitor;"
      option B: "ALTER WAREHOUSE my_wh UNSET RESOURCE_MONITOR;"
      option C: "ALTER WAREHOUSE my_wh SET RESOURCE_MONITOR = NULL;"
      option D: "Both B and C achieve the same result"
    correct Answer: "D"
    explanation: >
      D is correct because both ALTER WAREHOUSE ... UNSET RESOURCE_MONITOR and ALTER WAREHOUSE
      ... SET RESOURCE_MONITOR = NULL effectively remove the resource monitor assignment from
      the warehouse. A drops the entire monitor, not just the association. B and C are both
      individually valid, so D is the best answer.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "154"
    question: "Which query calculates the average daily credit consumption for each warehouse over the past 90 days?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME,
        SUM(CREDITS_USED) / 90 AS AVG_DAILY_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('day', -90, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
        ORDER BY AVG_DAILY_CREDITS DESC;
      option B: >
        SELECT WAREHOUSE_NAME, AVG(CREDITS_USED) AS AVG_DAILY_CREDITS
        FROM INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('day', -90, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME;
      option C: >
        SELECT WAREHOUSE_NAME, CREDITS_USED / 90
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        LIMIT 10;
      option D: >
        SELECT AVG(CREDITS_USED) FROM SNOWFLAKE.ACCOUNT_USAGE.METERING_DAILY_HISTORY
        WHERE START_TIME >= DATEADD('day', -90, CURRENT_TIMESTAMP());
    correct Answer: "A"
    explanation: >
      A is correct because it sums total credits for each warehouse over 90 days from
      ACCOUNT_USAGE (which supports 365-day lookback) and divides by 90 to get the daily
      average. B is wrong because INFORMATION_SCHEMA only retains 14 days. C does not filter
      by date or aggregate properly. D does not group by warehouse.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "155"
    question: "What is the impact of warehouse resizing on currently running queries?"
    their_options:
      option A: "All running queries are cancelled immediately"
      option B: "Running queries continue on the current resources; new resources are available for subsequent queries"
      option C: "Running queries are paused, then resumed on the new size"
      option D: "The resize fails if queries are running"
    correct Answer: "B"
    explanation: >
      B is correct because when a warehouse is resized, currently running queries continue
      using the existing compute resources. The resized resources become available for new
      queries submitted after the resize completes. A is wrong because queries are not
      cancelled. C is wrong because queries are not paused. D is wrong because resizing
      does not fail due to running queries.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "156"
    question: "What does a high ratio of BYTES_SCANNED to ROWS_PRODUCED in QUERY_HISTORY suggest?"
    their_options:
      option A: "The query is perfectly optimized"
      option B: "The query is scanning a lot of data but returning few rows, suggesting poor filtering or missing pruning"
      option C: "The warehouse is too large"
      option D: "The data is heavily compressed"
    correct Answer: "B"
    explanation: >
      B is correct because a high BYTES_SCANNED to ROWS_PRODUCED ratio indicates the query
      reads far more data than it returns, suggesting inefficient filtering, lack of
      clustering on filter columns, or missing WHERE clauses. A is the opposite of what
      this ratio indicates. C is unrelated. D is unrelated to the ratio.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "157"
    question: "How can you identify warehouses that are frequently starting and stopping (warehouse thrashing)?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME, COUNT(*) AS EVENT_COUNT
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_EVENTS_HISTORY
        WHERE EVENT_NAME IN ('RESUME_WAREHOUSE', 'SUSPEND_WAREHOUSE')
        AND TIMESTAMP >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
        ORDER BY EVENT_COUNT DESC;
      option B: "SHOW WAREHOUSES WHERE THRASHING = TRUE;"
      option C: "SELECT * FROM WAREHOUSE_THRASHING_HISTORY;"
      option D: "Check the AUTO_SUSPEND value only"
    correct Answer: "A"
    explanation: >
      A is correct because counting RESUME and SUSPEND events from WAREHOUSE_EVENTS_HISTORY
      over a time period reveals how frequently each warehouse is cycling. High event counts
      indicate thrashing. B is not valid syntax. C is not a real view. D only shows
      configuration, not actual behavior.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "158"
    question: "What is the recommended AUTO_SUSPEND setting for ETL/batch processing warehouses?"
    their_options:
      option A: "0 (never suspend) during batch runs, then manually suspend after"
      option B: "60 seconds for maximum cost savings"
      option C: "A short value like 60-120 seconds since batch jobs have defined start/end times"
      option D: "600 seconds (default) for all workloads"
    correct Answer: "C"
    explanation: >
      C is correct because for ETL/batch warehouses, a short AUTO_SUSPEND (60-120 seconds)
      is recommended since batch jobs have known execution patterns and the warehouse should
      suspend quickly after the batch completes. A requires manual intervention. B is fine
      but 120 seconds also works. D is too long for batch workloads that have clear end times.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "159"
    question: "What is the recommended AUTO_SUSPEND setting for interactive/BI reporting warehouses?"
    their_options:
      option A: "60 seconds for minimum cost"
      option B: "A moderate value (5-10 minutes) to balance cost with avoiding frequent cold starts"
      option C: "NULL (never suspend) for instant availability"
      option D: "3600 seconds (1 hour)"
    correct Answer: "B"
    explanation: >
      B is correct because interactive/BI warehouses benefit from a moderate AUTO_SUSPEND to
      avoid frequent cold starts (which cause QUEUED_PROVISIONING_TIME) while still controlling
      costs during longer idle periods. A may cause too many cold starts. C wastes credits
      during off-hours. D is generally too long.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "160"
    question: "Which system function returns the current warehouse being used by the session?"
    their_options:
      option A: "CURRENT_WAREHOUSE()"
      option B: "SESSION_WAREHOUSE()"
      option C: "GET_WAREHOUSE()"
      option D: "ACTIVE_WAREHOUSE()"
    correct Answer: "A"
    explanation: >
      A is correct because CURRENT_WAREHOUSE() returns the name of the warehouse currently
      in use by the session. B, C, and D are not valid Snowflake functions.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "161"
    question: "What does the QUERY_ACCELERATION_HISTORY view NOT include?"
    their_options:
      option A: "Credits used by the acceleration service"
      option B: "Warehouse name"
      option C: "The exact speedup factor achieved for each query"
      option D: "Time interval of the acceleration usage"
    correct Answer: "C"
    explanation: >
      C is correct because QUERY_ACCELERATION_HISTORY does not include per-query speedup
      factors. It tracks credits consumed by the service at the warehouse level over time
      intervals. A, B, and D are included in the view.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "162"
    question: "A company uses tags to track warehouse costs by department. Which query shows total credits by department tag?"
    their_options:
      option A: >
        SELECT TV.TAG_VALUE AS DEPARTMENT, SUM(WMH.CREDITS_USED) AS TOTAL_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY WMH
        JOIN SNOWFLAKE.ACCOUNT_USAGE.TAG_REFERENCES TV
        ON WMH.WAREHOUSE_NAME = TV.OBJECT_NAME
        AND TV.TAG_NAME = 'DEPARTMENT'
        AND TV.DOMAIN = 'WAREHOUSE'
        WHERE WMH.START_TIME >= DATEADD('month', -1, CURRENT_TIMESTAMP())
        GROUP BY TV.TAG_VALUE ORDER BY TOTAL_CREDITS DESC;
      option B: "SELECT DEPARTMENT, SUM(CREDITS) FROM WAREHOUSE_COSTS GROUP BY DEPARTMENT;"
      option C: "SHOW WAREHOUSE TAGS;"
      option D: "SELECT * FROM TAG_USAGE WHERE OBJECT_TYPE = 'WAREHOUSE';"
    correct Answer: "A"
    explanation: >
      A is correct because it joins WAREHOUSE_METERING_HISTORY with TAG_REFERENCES to
      aggregate credit consumption by the DEPARTMENT tag value. B references a non-existent
      view. C is not valid syntax. D does not exist as a standard view and does not include
      credit data.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "163"
    question: "What does a warehouse in 'Resizing' state mean?"
    their_options:
      option A: "The warehouse is being deleted"
      option B: "The warehouse is in the process of adding or removing compute resources due to a size change"
      option C: "The warehouse is being moved to a different region"
      option D: "The warehouse is upgrading its Snowflake edition"
    correct Answer: "B"
    explanation: >
      B is correct because 'Resizing' state indicates the warehouse is currently provisioning
      or deprovisioning compute nodes due to a size change (e.g., from Medium to Large). A is
      wrong because deletion is a DROP operation. C is wrong because warehouses cannot be moved
      between regions. D is wrong because editions are account-level.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "164"
    question: "Which approach is best for monitoring credit trends over multiple months?"
    their_options:
      option A: "Use INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY"
      option B: "Use SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY with date aggregation"
      option C: "Use SHOW WAREHOUSES"
      option D: "Contact Snowflake Support for historical reports"
    correct Answer: "B"
    explanation: >
      B is correct because ACCOUNT_USAGE retains up to 365 days of data, making it ideal for
      multi-month trend analysis. You can aggregate by month or week. A only has 14 days. C
      shows current state only. D is unnecessary when self-service tools exist.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "165"
    question: "How does Snowflake bill for a warehouse that is resized while running?"
    their_options:
      option A: "The new size is billed from the time of the resize command"
      option B: "The old size continues to be billed until the current hour ends"
      option C: "Credits for both old and new size are charged during the resize transition, with the new size billed once the resize completes"
      option D: "No credits are charged during the resize process"
    correct Answer: "C"
    explanation: >
      C is correct because during a resize, the existing nodes continue to run (and are billed)
      while new nodes are being provisioned. Once the resize completes, the new size rate
      applies. There may be a brief overlap where both old and new resources are active.
      A is oversimplified. B is wrong because billing changes with the resize. D is wrong
      because credits are always charged for running resources.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "166"
    question: "Which parameter determines how long a query can wait in the queue before being cancelled?"
    their_options:
      option A: "STATEMENT_TIMEOUT_IN_SECONDS"
      option B: "STATEMENT_QUEUED_TIMEOUT_IN_SECONDS"
      option C: "MAX_QUEUE_TIME"
      option D: "QUEUE_TIMEOUT"
    correct Answer: "B"
    explanation: >
      B is correct because STATEMENT_QUEUED_TIMEOUT_IN_SECONDS sets the maximum time a query
      can remain in the queue waiting for warehouse resources before being automatically
      cancelled. A controls total execution time, not queue time. C and D are not valid
      Snowflake parameters.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "167"
    question: "What is the default value for STATEMENT_QUEUED_TIMEOUT_IN_SECONDS?"
    their_options:
      option A: "0 (no timeout, wait indefinitely)"
      option B: "60 seconds"
      option C: "300 seconds"
      option D: "3600 seconds"
    correct Answer: "A"
    explanation: >
      A is correct because the default value is 0, meaning queries will wait in the queue
      indefinitely by default until warehouse resources become available. B, C, and D are
      specific timeout values that must be explicitly set.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "168"
    question: "A company wants to ensure no single query runs for more than 1 hour on any warehouse. How should they configure this?"
    their_options:
      option A: "ALTER ACCOUNT SET STATEMENT_TIMEOUT_IN_SECONDS = 3600;"
      option B: "Set STATEMENT_TIMEOUT_IN_SECONDS = 3600 on each warehouse individually"
      option C: "Both A and B would work; A applies globally, B is per-warehouse"
      option D: "Create a resource monitor with a 1-hour limit"
    correct Answer: "C"
    explanation: >
      C is correct because STATEMENT_TIMEOUT_IN_SECONDS can be set at the account level (A)
      for global enforcement, or per-warehouse (B) for targeted control. Both achieve the
      goal. The account level applies to all warehouses. D is wrong because resource monitors
      control credits, not individual query runtime.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "169"
    question: "How does the QUERY_HISTORY table function in INFORMATION_SCHEMA differ from the QUERY_HISTORY view in ACCOUNT_USAGE?"
    their_options:
      option A: "They are identical in all aspects"
      option B: "INFORMATION_SCHEMA version has 7-day retention with no latency; ACCOUNT_USAGE has 365-day retention with up to 45 minutes latency"
      option C: "INFORMATION_SCHEMA version shows more columns"
      option D: "ACCOUNT_USAGE version only shows successful queries"
    correct Answer: "B"
    explanation: >
      B is correct because the INFORMATION_SCHEMA QUERY_HISTORY table function retains data
      for 7 days with no latency (real-time), while the ACCOUNT_USAGE version retains 365
      days but has a latency of up to 45 minutes. A is wrong because they differ in retention
      and latency. C is wrong; columns are similar. D is wrong because both show all statuses.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "170"
    question: "Which INFORMATION_SCHEMA table function syntax is correct for querying recent query history?"
    their_options:
      option A: "SELECT * FROM INFORMATION_SCHEMA.QUERY_HISTORY WHERE START_TIME > DATEADD('day', -1, CURRENT_TIMESTAMP());"
      option B: "SELECT * FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(DATEADD('hour', -1, CURRENT_TIMESTAMP())));"
      option C: "SELECT * FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY());"
      option D: "Both B and C are valid syntaxes"
    correct Answer: "D"
    explanation: >
      D is correct because INFORMATION_SCHEMA.QUERY_HISTORY is a table function that can be
      called with or without parameters. C calls it with defaults, and B passes a time filter.
      A is wrong because the INFORMATION_SCHEMA version must be called as a table function
      using TABLE() syntax, not queried directly like a view.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "171"
    question: "What parameter in the INFORMATION_SCHEMA.QUERY_HISTORY table function limits results to a specific warehouse?"
    their_options:
      option A: "WAREHOUSE_NAME =>"
      option B: "WAREHOUSE =>"
      option C: "WH_NAME =>"
      option D: "FILTER_WAREHOUSE =>"
    correct Answer: "A"
    explanation: >
      A is correct because the INFORMATION_SCHEMA.QUERY_HISTORY table function accepts a
      WAREHOUSE_NAME parameter to filter results for a specific warehouse. B, C, and D are
      not valid parameter names for this function.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "172"
    question: "Your XL warehouse has been running for the past week with an average of only 2 concurrent queries and no queuing. What is the recommended action?"
    their_options:
      option A: "Keep the warehouse size since it provides fast query performance"
      option B: "Consider downsizing to a smaller warehouse to save credits while monitoring for performance regression"
      option C: "Add multi-cluster scaling"
      option D: "Increase AUTO_SUSPEND to reduce cold starts"
    correct Answer: "B"
    explanation: >
      B is correct because with only 2 concurrent queries and no queuing, an XL warehouse
      (16 credits/hour) is likely oversized. Downsizing to Large or Medium would reduce costs
      significantly. Monitoring after the change ensures performance remains acceptable.
      A wastes credits. C is unnecessary without queuing. D does not address the oversizing.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "173"
    question: "Which event type in WAREHOUSE_EVENTS_HISTORY indicates a multi-cluster warehouse added a cluster?"
    their_options:
      option A: "SCALE_UP"
      option B: "ADD_CLUSTER"
      option C: "RESUME_CLUSTER"
      option D: "CREATE_CLUSTER"
    correct Answer: "C"
    explanation: >
      C is correct because in WAREHOUSE_EVENTS_HISTORY, individual cluster start events in
      a multi-cluster warehouse are captured as RESUME_CLUSTER events. A, B, and D are not
      the actual event names used in Snowflake's warehouse events tracking.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "174"
    question: "Which credit cost is the most expensive per hour?"
    their_options:
      option A: "X-Small warehouse (1 credit/hour)"
      option B: "Small warehouse (2 credits/hour)"
      option C: "6X-Large warehouse (512 credits/hour)"
      option D: "4X-Large warehouse (128 credits/hour)"
    correct Answer: "C"
    explanation: >
      C is correct. The 6X-Large warehouse consumes 512 credits per hour, making it the most
      expensive standard warehouse size. Each size doubles the credits: X-Small=1, Small=2,
      Medium=4, Large=8, XL=16, 2XL=32, 3XL=64, 4XL=128, 5XL=256, 6XL=512.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "175"
    question: "What does the 'is_current' column in SHOW WAREHOUSES indicate?"
    their_options:
      option A: "Whether the warehouse is currently running"
      option B: "Whether the warehouse is the one currently being used by the session"
      option C: "Whether the warehouse is the most recently created"
      option D: "Whether the warehouse configuration is up to date"
    correct Answer: "B"
    explanation: >
      B is correct because is_current indicates whether the warehouse is the active warehouse
      for the current user session (set via USE WAREHOUSE). A describes the state column.
      C is not what this column indicates. D is incorrect.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "176"
    question: "A company notices their cloud services costs are above the 10% adjustment threshold. What should they investigate?"
    their_options:
      option A: "They have too many large warehouses"
      option B: "Excessive SHOW/DESCRIBE commands, frequent metadata operations, complex query compilation, or many small queries with short execution times"
      option C: "Their storage costs are too high"
      option D: "They need to upgrade their Snowflake edition"
    correct Answer: "B"
    explanation: >
      B is correct because cloud services costs that exceed the 10% threshold are typically
      caused by heavy metadata operations (SHOW, DESCRIBE, INFORMATION_SCHEMA queries),
      excessive query compilation for complex or very frequent short queries, and other
      cloud services layer operations. A is about compute costs. C is about storage.
      D does not impact cloud services costs.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "177"
    question: "How can you view the number of credits consumed by cloud services separately from compute?"
    their_options:
      option A: "SELECT WAREHOUSE_NAME, CREDITS_USED, CREDITS_USED_CLOUD_SERVICES FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY;"
      option B: "SHOW CLOUD_SERVICES_CREDITS;"
      option C: "SELECT * FROM CLOUD_SERVICES_BILLING;"
      option D: "Cloud services credits cannot be viewed separately"
    correct Answer: "A"
    explanation: >
      A is correct because WAREHOUSE_METERING_HISTORY includes separate columns for
      CREDITS_USED (compute) and CREDITS_USED_CLOUD_SERVICES. B and C are not valid
      commands/views. D is wrong because they can be viewed separately.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "178"
    question: "What is the benefit of using Snowflake's built-in Cost Management features in Snowsight?"
    their_options:
      option A: "They provide only basic warehouse monitoring"
      option B: "They offer visual dashboards for credit consumption, cost trends, resource monitor status, and budget tracking without writing SQL"
      option C: "They replace resource monitors entirely"
      option D: "They are only available to Enterprise edition customers"
    correct Answer: "B"
    explanation: >
      B is correct because Snowsight's Cost Management features provide visual dashboards
      showing credit consumption trends, budget status, resource monitor details, and cost
      breakdowns without requiring SQL queries. A understates the capability. C is wrong
      because they complement, not replace resource monitors. D is wrong because basic cost
      management features are available in all editions.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst, Architect

  - Question No: "179"
    question: "Which monitoring approach helps identify queries that would benefit from clustering optimization rather than warehouse scaling?"
    their_options:
      option A: "Check WAREHOUSE_LOAD_HISTORY for high AVG_QUEUED_LOAD"
      option B: "Check QUERY_HISTORY for high BYTES_SCANNED relative to the table size and low partition pruning efficiency"
      option C: "Check WAREHOUSE_METERING_HISTORY for high CREDITS_USED"
      option D: "Check WAREHOUSE_EVENTS_HISTORY for frequent resizing"
    correct Answer: "B"
    explanation: >
      B is correct because high BYTES_SCANNED relative to the table size combined with low
      partition pruning (scanning most partitions) indicates the table would benefit from
      clustering, which improves pruning and reduces data scannedâ€”a table optimization, not
      a warehouse scaling issue. A indicates concurrency issues. C shows total cost but not
      the root cause. D shows resize events, not query-level issues.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "180"
    question: "What is the SNOWFLAKE.ACCOUNT_USAGE.METERING_HISTORY view used for?"
    their_options:
      option A: "Only tracking warehouse compute credits"
      option B: "Tracking all metering across compute, serverless features, and cloud services with a SERVICE_TYPE column"
      option C: "Tracking storage metering only"
      option D: "Tracking data transfer metering only"
    correct Answer: "B"
    explanation: >
      B is correct because METERING_HISTORY provides a unified view of all credit consumption
      across different service types, identifiable by the SERVICE_TYPE column (e.g.,
      WAREHOUSE_METERING, AUTO_CLUSTERING, PIPE, MATERIALIZED_VIEW_MAINTENANCE, etc.). A is
      too limited. C and D cover only specific areas.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "181"
    question: "A warehouse has MAX_CLUSTER_COUNT = 3 and all 3 clusters are running, but queries are still queuing. What should you do?"
    their_options:
      option A: "Increase MAX_CLUSTER_COUNT to allow more clusters"
      option B: "Scale up the warehouse size AND increase MAX_CLUSTER_COUNT"
      option C: "Switch to ECONOMY scaling policy"
      option D: "Reduce MAX_CONCURRENCY_LEVEL"
    correct Answer: "A"
    explanation: >
      A is correct as the most direct action. If all clusters are running and queries are still
      queuing, increasing MAX_CLUSTER_COUNT allows more clusters to be added. B may also be
      valid but is more expensive and complex. C would make the problem worse by being more
      conservative. D would reduce capacity, worsening the issue.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "182"
    question: "Which SQL identifies users who are consuming the most warehouse credits?"
    their_options:
      option A: >
        SELECT USER_NAME, WAREHOUSE_NAME, SUM(EXECUTION_TIME) AS TOTAL_EXEC_MS
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE START_TIME >= DATEADD('day', -30, CURRENT_TIMESTAMP())
        GROUP BY USER_NAME, WAREHOUSE_NAME
        ORDER BY TOTAL_EXEC_MS DESC LIMIT 20;
      option B: "SELECT USER_NAME, CREDITS_USED FROM USER_CREDIT_HISTORY;"
      option C: "SHOW USER CREDITS;"
      option D: "SELECT * FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY ORDER BY CREDITS DESC;"
    correct Answer: "A"
    explanation: >
      A is correct because by aggregating EXECUTION_TIME per user and warehouse from
      QUERY_HISTORY, you can approximate which users are driving the most warehouse resource
      consumption (longer execution times on larger warehouses = more credits). B is not a
      real view. C is not valid syntax. D is wrong because LOGIN_HISTORY has no CREDITS column.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "183"
    question: "What monitoring view helps you understand the pattern of warehouse usage throughout the day?"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY grouped by HOUR(START_TIME)"
      option B: "LOGIN_HISTORY grouped by hour"
      option C: "STORAGE_USAGE by hour"
      option D: "DATA_TRANSFER_HISTORY by hour"
    correct Answer: "A"
    explanation: >
      A is correct because WAREHOUSE_METERING_HISTORY with hourly granularity allows you to
      group by hour of day to see usage patterns (peak hours, off-hours, etc.). B shows login
      patterns, not warehouse usage. C tracks storage, not compute. D tracks data transfers.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "184"
    question: "What is the purpose of the ENABLE_QUERY_ACCELERATION parameter on a warehouse?"
    their_options:
      option A: "It enables caching for all queries"
      option B: "It enables the Query Acceleration Service which offloads portions of eligible queries to shared compute resources"
      option C: "It enables parallel processing within the warehouse"
      option D: "It enables automatic warehouse resizing based on query complexity"
    correct Answer: "B"
    explanation: >
      B is correct because ENABLE_QUERY_ACCELERATION activates the Query Acceleration Service
      (QAS) on a warehouse, which offloads portions of eligible queries to serverless compute
      resources for faster execution. A is about caching, which is automatic. C is already
      the default behavior. D describes a feature that does not exist.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "185"
    question: "What does QUERY_ACCELERATION_MAX_SCALE_FACTOR = 0 mean?"
    their_options:
      option A: "Query acceleration is disabled"
      option B: "Query acceleration has no upper limit on the scale factor"
      option C: "Query acceleration uses the default scale factor"
      option D: "Query acceleration uses minimal resources"
    correct Answer: "B"
    explanation: >
      B is correct because setting QUERY_ACCELERATION_MAX_SCALE_FACTOR to 0 means there is
      no upper limit on the scale factor, allowing the QAS to use as many serverless resources
      as needed. A is wrong because 0 means unlimited, not disabled. C is wrong because 0 is
      a specific setting. D is wrong because 0 means no limit.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "186"
    question: "How can you monitor whether the result cache is being effectively used across your warehouses?"
    their_options:
      option A: "Check WAREHOUSE_METERING_HISTORY for cache metrics"
      option B: "Query QUERY_HISTORY and look for queries with very low EXECUTION_TIME and BYTES_SCANNED = 0"
      option C: "Check the RESULT_CACHE_HIT_RATIO view"
      option D: "Use SHOW CACHES command"
    correct Answer: "B"
    explanation: >
      B is correct because queries served from the result cache have extremely low
      EXECUTION_TIME (near 0) and BYTES_SCANNED = 0 since no warehouse resources are used.
      Counting these versus total queries gives you cache effectiveness. A does not have
      cache metrics. C is not a real view. D is not a valid command.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "187"
    question: "What is the effect on monitoring when a warehouse is renamed?"
    their_options:
      option A: "All historical data is lost"
      option B: "Historical data in ACCOUNT_USAGE views will show the new name for past records"
      option C: "Historical data in ACCOUNT_USAGE retains the old name; new entries use the new name"
      option D: "The rename is not allowed if historical data exists"
    correct Answer: "C"
    explanation: >
      C is correct because when a warehouse is renamed, historical records in ACCOUNT_USAGE
      views retain the original warehouse name. New records after the rename use the new
      name. This can make historical analysis across the rename event more complex. A is
      wrong because data is not lost. B is wrong because past records are not updated.
      D is wrong because renames are always allowed.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "188"
    question: "Which of the following is NOT a valid warehouse size in Snowflake?"
    their_options:
      option A: "X-Small"
      option B: "Medium"
      option C: "3X-Large"
      option D: "7X-Large"
    correct Answer: "D"
    explanation: >
      D is correct because 7X-Large is not a valid Snowflake warehouse size. Valid sizes are
      X-Small, Small, Medium, Large, X-Large, 2X-Large, 3X-Large, 4X-Large, 5X-Large, and
      6X-Large. A, B, and C are all valid sizes.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "189"
    question: "What happens to the result cache when a warehouse is suspended and resumed?"
    their_options:
      option A: "The result cache is cleared"
      option B: "The result cache is preserved because it is maintained in the cloud services layer"
      option C: "The result cache is partially preserved"
      option D: "The result cache is backed up to remote storage"
    correct Answer: "B"
    explanation: >
      B is correct because the result cache is maintained at the cloud services layer, not
      at the warehouse level. Therefore, suspending and resuming a warehouse does not affect
      the result cache. Note: the LOCAL DISK cache (SSD) IS lost on suspend, but the result
      cache is separate. A confuses result cache with local disk cache. C and D are incorrect.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "190"
    question: "A query profile shows significant time spent in 'Remote Disk I/O'. What does this indicate?"
    their_options:
      option A: "The query is reading data from the local SSD cache"
      option B: "The query is reading data from remote cloud storage because the data is not in the local cache"
      option C: "The query is writing results to an external stage"
      option D: "The network between warehouses is slow"
    correct Answer: "B"
    explanation: >
      B is correct because high 'Remote Disk I/O' indicates the query is fetching data from
      the underlying cloud storage (S3, Azure Blob, GCS) rather than from the local SSD
      cache. This is slower and indicates a cold cache. A describes local I/O. C is about
      unloading data. D is not related to Remote Disk I/O.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "191"
    question: "How can you identify failed queries on a specific warehouse in the last 24 hours?"
    their_options:
      option A: >
        SELECT QUERY_ID, QUERY_TEXT, ERROR_CODE, ERROR_MESSAGE
        FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(
        DATEADD('hour', -24, CURRENT_TIMESTAMP()),
        CURRENT_TIMESTAMP(),
        WAREHOUSE_NAME => 'MY_WH'))
        WHERE EXECUTION_STATUS = 'FAIL';
      option B: "SHOW FAILED QUERIES ON WAREHOUSE MY_WH;"
      option C: "SELECT * FROM WAREHOUSE_ERRORS WHERE WAREHOUSE_NAME = 'MY_WH';"
      option D: "DESCRIBE WAREHOUSE MY_WH ERRORS;"
    correct Answer: "A"
    explanation: >
      A is correct because it uses the INFORMATION_SCHEMA QUERY_HISTORY table function
      filtered by warehouse and status = 'FAIL', returning error codes and messages. B, C,
      and D are not valid Snowflake commands or views.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "192"
    question: "What does monitoring PERCENTAGE_SCANNED_FROM_CACHE in Query Profile tell you about warehouse effectiveness?"
    their_options:
      option A: "A high percentage means the warehouse is too large"
      option B: "A high percentage means the local disk cache is warm and effective, reducing remote storage reads"
      option C: "A low percentage means the data is corrupted"
      option D: "This metric is not related to warehouse performance"
    correct Answer: "B"
    explanation: >
      B is correct because a high PERCENTAGE_SCANNED_FROM_CACHE means most data was read
      from the local SSD cache, which is faster than reading from remote storage. This
      indicates the warehouse cache is warm and effective. A is wrong because cache
      effectiveness is not about warehouse size. C is wrong. D is wrong because it is
      directly related to warehouse performance.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "193"
    question: "Which scenario would make the local disk cache most effective? (Select TWO)"
    their_options:
      option A: "The warehouse runs continuously without suspending"
      option B: "Queries frequently access the same data/tables"
      option C: "The warehouse is suspended every 60 seconds"
      option D: "Each query accesses completely different data"
      option E: "The warehouse is resized frequently"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. A continuous warehouse (A) retains its local cache, and queries
      accessing the same data (B) benefit from cached micro-partitions. C is wrong because
      frequent suspend/resume clears the cache. D is wrong because unique data access
      prevents cache reuse. E is wrong because resizing can disrupt the cache.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "194"
    question: "What does the Snowflake Cost Management interface in Snowsight allow you to configure?"
    their_options:
      option A: "Only view historical costs"
      option B: "View costs, set budgets, create budget alerts, and track spending against budgets"
      option C: "Modify warehouse sizes directly"
      option D: "Create new warehouses"
    correct Answer: "B"
    explanation: >
      B is correct because Snowsight's Cost Management provides visibility into costs, allows
      setting budgets with notifications, and tracks spending against those budgets. A is too
      limited. C and D are warehouse management functions, not cost management features.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst, Architect

  - Question No: "195"
    question: "Can you set a resource monitor trigger above 100%?"
    their_options:
      option A: "No, 100% is the maximum threshold"
      option B: "Yes, you can set triggers above 100% to monitor overshoot (e.g., 110%, 120%)"
      option C: "Yes, but only for NOTIFY actions"
      option D: "No, triggers must be between 0% and 50%"
    correct Answer: "B"
    explanation: >
      B is correct because resource monitor triggers CAN be set above 100%. This is useful
      because credit usage is not checked continuouslyâ€”there may be a delay between reaching
      100% and the check happening, causing overshoot. Triggers at 110% or 120% provide
      additional notifications. A is wrong. C is wrong because all actions work above 100%.
      D is an arbitrary incorrect range.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "196"
    question: "Why might credit usage exceed the 100% threshold of a resource monitor before the SUSPEND action triggers?"
    their_options:
      option A: "Resource monitors check usage periodically, not in real-time, so consumption can exceed the threshold between checks"
      option B: "SUSPEND actions are always delayed by 1 hour"
      option C: "Credits are calculated at the end of the month"
      option D: "Resource monitors only work on weekdays"
    correct Answer: "A"
    explanation: >
      A is correct because resource monitors check credit usage at periodic intervals, not
      continuously. Between checks, a warehouse can consume credits that push usage past the
      threshold. This is why setting triggers slightly above 100% (e.g., 110%) with
      SUSPEND_IMMEDIATE can be useful. B, C, and D are all incorrect.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "197"
    question: "Which query shows the hourly credit consumption pattern for a specific warehouse over the last week?"
    their_options:
      option A: >
        SELECT DATE_TRUNC('hour', START_TIME) AS HOUR,
        SUM(CREDITS_USED) AS HOURLY_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE WAREHOUSE_NAME = 'MY_WH'
        AND START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        GROUP BY HOUR ORDER BY HOUR;
      option B: "SHOW WAREHOUSE MY_WH HOURLY_CREDITS;"
      option C: "SELECT HOURLY_CREDITS FROM WAREHOUSE_HOURLY_USAGE WHERE WH = 'MY_WH';"
      option D: "DESCRIBE WAREHOUSE MY_WH CREDITS;"
    correct Answer: "A"
    explanation: >
      A is correct because it queries ACCOUNT_USAGE, truncates to the hour, sums credits,
      and filters by warehouse name and date range. B, C, and D are not valid Snowflake
      commands or views.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "198"
    question: "What information does WAREHOUSE_EVENTS_HISTORY provide that WAREHOUSE_METERING_HISTORY does not?"
    their_options:
      option A: "Credit consumption per hour"
      option B: "Specific events like warehouse creation, resize, suspend, resume, and cluster scaling timestamps"
      option C: "Query execution details"
      option D: "User login information"
    correct Answer: "B"
    explanation: >
      B is correct because WAREHOUSE_EVENTS_HISTORY captures discrete events (CREATE, DROP,
      RESIZE, SUSPEND, RESUME, cluster scale events) with timestamps, while
      WAREHOUSE_METERING_HISTORY only tracks credit consumption over intervals. A is what
      METERING_HISTORY provides. C is in QUERY_HISTORY. D is in LOGIN_HISTORY.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "199"
    question: "How do you check if a specific warehouse has a resource monitor assigned?"
    their_options:
      option A: "SHOW WAREHOUSES LIKE 'MY_WH' and check the resource_monitor column"
      option B: "DESCRIBE RESOURCE MONITOR FOR WAREHOUSE MY_WH"
      option C: "SELECT RESOURCE_MONITOR FROM WAREHOUSE_CONFIG WHERE NAME = 'MY_WH'"
      option D: "SHOW RESOURCE MONITORS ON WAREHOUSE MY_WH"
    correct Answer: "A"
    explanation: >
      A is correct because SHOW WAREHOUSES includes a resource_monitor column that shows
      which resource monitor is assigned to each warehouse. B, C, and D are not valid
      Snowflake commands.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "200"
    question: "A Snowflake Architect needs to design a monitoring strategy for 100+ warehouses across 5 departments. What is the BEST approach?"
    their_options:
      option A: "Create one resource monitor per warehouse"
      option B: "Use object tags for department attribution, resource monitors per department group, and automated alerts via Snowflake Alerts querying ACCOUNT_USAGE views"
      option C: "Only use the Snowsight UI to monitor manually"
      option D: "Create a single account-level resource monitor for everything"
    correct Answer: "B"
    explanation: >
      B is correct because a comprehensive strategy combines multiple tools: object tags enable
      department-level cost attribution, resource monitors per department provide automated
      credit controls, and Snowflake Alerts enable custom monitoring rules. A creates
      management overhead. C is not scalable. D provides no granularity by department.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "201"
    question: "What is the METERING_DAILY_HISTORY view in ACCOUNT_USAGE?"
    their_options:
      option A: "A view showing daily credit consumption aggregated by service type"
      option B: "A view showing daily login counts"
      option C: "A view showing daily data loading metrics"
      option D: "A view showing daily warehouse resize events"
    correct Answer: "A"
    explanation: >
      A is correct because METERING_DAILY_HISTORY aggregates daily credit consumption by
      service type (compute, serverless features, etc.), providing a high-level daily cost
      overview. B, C, and D describe other types of data not in this view.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "202"
    question: "Which column in QUERY_HISTORY can help identify queries that time out?"
    their_options:
      option A: "EXECUTION_STATUS = 'FAIL' with ERROR_CODE related to timeout"
      option B: "TIMEOUT_FLAG = TRUE"
      option C: "QUERY_STATE = 'TIMED_OUT'"
      option D: "CANCELLED_BY = 'TIMEOUT'"
    correct Answer: "A"
    explanation: >
      A is correct because timed-out queries show EXECUTION_STATUS = 'FAIL' with a specific
      error code indicating statement timeout. B, C, and D are not actual columns or values
      in QUERY_HISTORY.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "203"
    question: "What does 'credit' represent in Snowflake's billing model?"
    their_options:
      option A: "A unit of currency equal to $1 USD"
      option B: "A unit of compute resources consumed; the dollar cost per credit varies by edition, region, and cloud provider"
      option C: "A unit of data storage"
      option D: "A unit of network bandwidth"
    correct Answer: "B"
    explanation: >
      B is correct because a Snowflake credit is a unit of compute consumption. The actual
      dollar cost per credit varies based on the Snowflake edition (Standard, Enterprise,
      Business Critical), cloud provider (AWS, Azure, GCP), and region. A is wrong because
      the cost per credit is not fixed at $1. C and D are incorrect units.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst, Architect

  - Question No: "204"
    question: "Which view would help you understand the cost breakdown between compute and serverless features for the entire account?"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY only"
      option B: "METERING_HISTORY with SERVICE_TYPE column"
      option C: "QUERY_HISTORY with WAREHOUSE_NAME column"
      option D: "STORAGE_USAGE"
    correct Answer: "B"
    explanation: >
      B is correct because METERING_HISTORY includes all credit consumption with a
      SERVICE_TYPE column that distinguishes between warehouse compute, auto_clustering,
      pipe, materialized_view_maintenance, search_optimization, and other service types.
      A only covers warehouses. C shows queries but not serverless. D covers storage only.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "205"
    question: "A user runs SELECT CURRENT_WAREHOUSE(); and gets NULL. What does this mean?"
    their_options:
      option A: "The user has no warehouses in the account"
      option B: "No warehouse is currently selected for the session (no USE WAREHOUSE executed)"
      option C: "The user's warehouse was just dropped"
      option D: "The user does not have the ACCOUNTADMIN role"
    correct Answer: "B"
    explanation: >
      B is correct because NULL from CURRENT_WAREHOUSE() means no warehouse has been set for
      the current session. The user needs to run USE WAREHOUSE <name> to select one. A is
      wrong because warehouses may exist but not be selected. C is possible but unlikely to
      be the typical reason. D is irrelevant to warehouse selection.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "206"
    question: "How do Snowflake Budgets differ from Resource Monitors?"
    their_options:
      option A: "They are the same feature with different names"
      option B: "Budgets track spending in currency across all services and send email alerts; Resource Monitors track warehouse credit usage and can suspend warehouses"
      option C: "Budgets can suspend warehouses; Resource Monitors cannot"
      option D: "Budgets only work at the organization level"
    correct Answer: "B"
    explanation: >
      B is correct because Budgets (introduced more recently) track costs in currency units
      across all service types and send email notifications, while Resource Monitors
      specifically track warehouse credit consumption and can take actions like NOTIFY,
      SUSPEND, and SUSPEND_IMMEDIATE. A is wrong because they are distinct features. C
      reverses the capabilities. D is wrong because budgets work at account and custom levels.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "207"
    question: "What does the ROWS_INSERTED column in QUERY_HISTORY indicate for warehouse monitoring?"
    their_options:
      option A: "The number of new rows added to the result cache"
      option B: "The number of rows inserted by DML operations, which can help assess the data volume processed by the warehouse"
      option C: "The number of rows in the warehouse queue"
      option D: "The total rows in all tables accessed by the query"
    correct Answer: "B"
    explanation: >
      B is correct because ROWS_INSERTED shows the number of rows inserted by DML operations
      (INSERT, MERGE, COPY INTO). Monitoring this helps assess the data volume and DML
      workload processed by the warehouse. A is wrong because the result cache is not tracked
      this way. C and D are incorrect interpretations.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "208"
    question: "Which query helps identify the busiest time periods for a warehouse?"
    their_options:
      option A: >
        SELECT HOUR(START_TIME) AS HOUR_OF_DAY,
        COUNT(*) AS QUERY_COUNT,
        AVG(TOTAL_ELAPSED_TIME) AS AVG_ELAPSED
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE WAREHOUSE_NAME = 'MY_WH'
        AND START_TIME >= DATEADD('day', -30, CURRENT_TIMESTAMP())
        GROUP BY HOUR_OF_DAY ORDER BY QUERY_COUNT DESC;
      option B: "SHOW WAREHOUSE BUSY_TIMES;"
      option C: "SELECT PEAK_TIME FROM WAREHOUSE_PEAK_USAGE;"
      option D: "DESCRIBE WAREHOUSE MY_WH BUSY_HOURS;"
    correct Answer: "A"
    explanation: >
      A is correct because it groups query history by hour of day to identify when the most
      queries run and their average duration, revealing peak usage times. B, C, and D are
      not valid Snowflake commands or views.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "209"
    question: "What is the impact of running SHOW commands (SHOW TABLES, SHOW DATABASES, etc.) on warehouse costs?"
    their_options:
      option A: "SHOW commands consume warehouse credits because they require compute resources"
      option B: "SHOW commands consume cloud services credits, not warehouse compute credits"
      option C: "SHOW commands are free and consume no credits"
      option D: "SHOW commands only consume credits if the warehouse is running"
    correct Answer: "B"
    explanation: >
      B is correct because SHOW commands are executed in the cloud services layer and consume
      cloud services credits, not warehouse compute credits. A is wrong because SHOW commands
      do not use warehouse compute. C is wrong because they do consume cloud services credits.
      D is wrong because SHOW commands work regardless of warehouse state.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "210"
    question: "A query's QUERY_ID is '01b12345-0001-1234-0000-00050001a00a'. How can you view its detailed profile?"
    their_options:
      option A: "Navigate to Snowsight > Activity > Query History > search for the Query ID > click on the query > Query Profile tab"
      option B: "Run EXPLAIN '01b12345-0001-1234-0000-00050001a00a';"
      option C: "Run SHOW PROFILE '01b12345-0001-1234-0000-00050001a00a';"
      option D: "Run DESCRIBE QUERY '01b12345-0001-1234-0000-00050001a00a';"
    correct Answer: "A"
    explanation: >
      A is correct because the Query Profile for a specific query is accessible via the
      Snowsight UI by navigating to Activity > Query History, finding the query by ID, and
      viewing the Profile tab. B (EXPLAIN) is for generating estimated plans, not viewing
      executed profiles. C and D are not valid commands.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "211"
    question: "What is a key indicator in the Query Profile that a query would benefit from the Query Acceleration Service?"
    their_options:
      option A: "High compilation time"
      option B: "Large scan operations with selective filters on large tables"
      option C: "Many small joins"
      option D: "Low rows produced"
    correct Answer: "B"
    explanation: >
      B is correct because the Query Acceleration Service is most beneficial for queries
      with large scan operations that have selective filters, as QAS can parallelize the
      scan across additional serverless compute nodes. A is cloud services layer. C is not
      specifically targeted by QAS. D does not indicate QAS eligibility.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "212"
    question: "How does Snowflake's per-second billing work after the initial 60-second minimum?"
    their_options:
      option A: "Every additional second is billed at the per-hour credit rate divided by 3600"
      option B: "Every additional minute is billed at the per-hour rate divided by 60"
      option C: "Billing stays at 60-second increments"
      option D: "No additional charges after the first minute"
    correct Answer: "A"
    explanation: >
      A is correct because after the 60-second minimum, Snowflake charges per-second based
      on the warehouse's hourly credit rate divided by 3600 seconds. For example, an X-Small
      warehouse (1 credit/hour) costs 1/3600 credits per additional second. B is wrong
      because it is per-second, not per-minute. C is wrong. D is wrong.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "213"
    question: "What monitoring strategy helps ensure compliance with a fixed annual Snowflake budget?"
    their_options:
      option A: "Only check costs at year-end"
      option B: "Set up an account-level resource monitor with FREQUENCY = YEARLY and CREDIT_QUOTA matching the annual allocation, with NOTIFY triggers at 25%, 50%, 75%, 90%, and SUSPEND at 100%"
      option C: "Rely on Snowflake Support to alert you"
      option D: "Use warehouse AUTO_SUSPEND = 60 on all warehouses"
    correct Answer: "B"
    explanation: >
      B is correct because an account-level yearly resource monitor with multiple NOTIFY
      triggers at regular intervals provides progressive warnings, and SUSPEND at 100%
      prevents overuse. A is reactive and risky. C relies on external support. D helps
      with individual warehouse costs but does not enforce an annual budget.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "214"
    question: "Which SQL function helps you get the query profile information programmatically?"
    their_options:
      option A: "GET_QUERY_OPERATOR_STATS()"
      option B: "SYSTEM$GET_QUERY_PROFILE()"
      option C: "QUERY_PROFILE()"
      option D: "EXPLAIN ANALYZE"
    correct Answer: "A"
    explanation: >
      A is correct because GET_QUERY_OPERATOR_STATS() is a table function that returns the
      query profile statistics (operator-level details) programmatically for a given query
      ID, allowing automated analysis. B is not the correct function name. C is not a
      function. D is not supported in Snowflake.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "215"
    question: "What is the syntax to use the QUERY_HISTORY_BY_WAREHOUSE table function?"
    their_options:
      option A: "SELECT * FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY_BY_WAREHOUSE('MY_WH'));"
      option B: "SELECT * FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(WAREHOUSE_NAME => 'MY_WH'));"
      option C: "SELECT * FROM INFORMATION_SCHEMA.QUERY_HISTORY WHERE WAREHOUSE = 'MY_WH';"
      option D: "CALL QUERY_HISTORY_BY_WAREHOUSE('MY_WH');"
    correct Answer: "B"
    explanation: >
      B is correct because QUERY_HISTORY in INFORMATION_SCHEMA is a table function that
      accepts WAREHOUSE_NAME as a named parameter. A is wrong because QUERY_HISTORY_BY_WAREHOUSE
      is not a separate function. C is wrong because INFORMATION_SCHEMA table functions
      must use TABLE() syntax. D is not valid syntax.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "216"
    question: "What are the benefits of using ACCOUNT_USAGE views over INFORMATION_SCHEMA for long-term monitoring? (Select TWO)"
    their_options:
      option A: "365-day data retention vs 14-day retention"
      option B: "No latency in data availability"
      option C: "Dropped objects are included in the data"
      option D: "Real-time data updates"
      option E: "Requires no special privileges"
    correct Answer: "A, C"
    explanation: >
      A and C are correct. ACCOUNT_USAGE provides 365-day retention (vs 14 days for
      INFORMATION_SCHEMA) and includes data about dropped objects, which INFORMATION_SCHEMA
      does not. B is wrong because ACCOUNT_USAGE has latency. D is wrong for the same reason.
      E is wrong because ACCOUNT_USAGE requires IMPORTED PRIVILEGES on the SNOWFLAKE database.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "217"
    question: "Which scenario demonstrates a common misconception about warehouse monitoring?"
    their_options:
      option A: "Believing that a larger warehouse always means faster queries"
      option B: "Understanding that query compilation happens in the cloud services layer"
      option C: "Knowing that suspended warehouses do not consume credits"
      option D: "Recognizing that multi-cluster warehouses can scale out"
    correct Answer: "A"
    explanation: >
      A is correct because a common misconception is that a larger warehouse always results
      in faster queries. In reality, many queries are limited by factors like data access
      patterns, join strategies, or cloud services compilationâ€”not compute power. Larger
      warehouses help with complex compute-intensive operations and reducing spillage. B, C,
      and D are all correct understandings, not misconceptions.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "218"
    question: "Which Snowflake edition is required to use multi-cluster warehouses?"
    their_options:
      option A: "Standard edition"
      option B: "Enterprise edition or higher"
      option C: "Business Critical edition only"
      option D: "All editions support multi-cluster warehouses"
    correct Answer: "B"
    explanation: >
      B is correct because multi-cluster warehouses require Enterprise edition or higher
      (Enterprise, Business Critical, or VPS). Standard edition only supports single-cluster
      warehouses. A is wrong. C is too restrictive. D is wrong because Standard does not
      support multi-cluster.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "219"
    question: "What is the difference between OPERATE and MODIFY privileges for warehouse monitoring actions?"
    their_options:
      option A: "They are the same privilege"
      option B: "OPERATE allows start/stop/resume/abort; MODIFY allows changing warehouse properties like size and auto_suspend"
      option C: "MODIFY allows start/stop; OPERATE allows changing properties"
      option D: "Both require ACCOUNTADMIN role"
    correct Answer: "B"
    explanation: >
      B is correct. OPERATE allows operational actions (start, stop, suspend, resume, abort
      queries). MODIFY allows changing warehouse properties (size, auto_suspend, scaling
      policy, etc.). They serve different purposes. A is wrong. C reverses them. D is wrong
      because these privileges can be granted to any role.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "220"
    question: "An ETL pipeline runs every hour and takes 15 minutes. The warehouse is XL with AUTO_SUSPEND = 600. How many credits are consumed in 24 hours?"
    their_options:
      option A: "96 credits (24 runs Ã— 4 credits per run)"
      option B: "384 credits (24 hours Ã— 16 credits/hour)"
      option C: "160 credits (24 runs Ã— 15 min active + 10 min idle per run Ã— 16 credits/hour)"
      option D: "Approximately 160 credits (each run keeps warehouse active for 25 minutes: 15 min execution + 10 min auto-suspend wait)"
    correct Answer: "D"
    explanation: >
      D is correct. Each hourly ETL run takes 15 minutes, then the warehouse idles for 10
      minutes (600 seconds) before auto-suspending. Total active time per run = 25 minutes.
      24 runs Ã— 25 minutes = 600 minutes = 10 hours. XL warehouse = 16 credits/hour.
      10 hours Ã— 16 = 160 credits. A uses wrong credit rate. B assumes 24-hour continuous
      running. C arrives at the right answer but the reasoning description is less precise.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "221"
    question: "What would be the cost savings if the warehouse in Question 220 changed AUTO_SUSPEND from 600 to 60?"
    their_options:
      option A: "No savings"
      option B: "Approximately 57.6 credits saved per day (reducing idle time from 10 min to 1 min per run)"
      option C: "All credits are eliminated"
      option D: "Approximately 16 credits saved per day"
    correct Answer: "B"
    explanation: >
      B is correct. With AUTO_SUSPEND = 60, active time per run = 15 min + 1 min = 16 min.
      24 runs Ã— 16 min = 384 min = 6.4 hours Ã— 16 credits/hour = 102.4 credits. Previous
      was 160 credits. Savings = 160 - 102.4 = 57.6 credits per day. A is wrong. C is wrong
      because compute is still needed. D is too low.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "222"
    question: "Which feature allows Snowflake to automatically suspend and resume warehouses for scheduled tasks?"
    their_options:
      option A: "Resource Monitors"
      option B: "Snowflake Tasks with a warehouse specified (AUTO_RESUME handles the resume)"
      option C: "Snowflake Alerts"
      option D: "Snowflake Streams"
    correct Answer: "B"
    explanation: >
      B is correct because when a Snowflake Task is assigned to a warehouse with AUTO_RESUME
      = TRUE, the warehouse automatically resumes when the task runs and auto-suspends after
      completion. A controls credits, not scheduling. C monitors conditions. D tracks data
      changes.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "223"
    question: "What does it mean if WAREHOUSE_METERING_HISTORY shows credits for a warehouse that has AUTO_SUSPEND = 60 and no queries in QUERY_HISTORY for that period?"
    their_options:
      option A: "The data is corrupted"
      option B: "The warehouse may have been kept alive by background operations, SHOW commands, or the 60-second minimum billing after brief activity"
      option C: "Resource monitors are consuming the credits"
      option D: "Another user is running queries you cannot see"
    correct Answer: "B"
    explanation: >
      B is correct. Credits can appear without visible queries due to the 60-second minimum
      billing for brief warehouse starts, background operations, or metadata operations that
      do not appear in QUERY_HISTORY. A is unlikely. C is wrong because resource monitors
      do not consume credits. D is possible but the more common explanation is B.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "224"
    question: "Which monitoring metric helps determine if a warehouse should be changed from single-cluster to multi-cluster?"
    their_options:
      option A: "High BYTES_SPILLED_TO_REMOTE_STORAGE per query"
      option B: "High AVG_QUEUED_LOAD with many concurrent users, where individual query execution time is acceptable"
      option C: "High COMPILATION_TIME"
      option D: "Low CREDITS_USED"
    correct Answer: "B"
    explanation: >
      B is correct because high queuing with acceptable individual query performance indicates
      the warehouse needs more concurrency capacity, which multi-cluster provides. A indicates
      need for upsizing (more memory per query). C is a cloud services issue. D suggests
      the warehouse is already efficient.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "225"
    question: "How can you find the average number of clusters running for a multi-cluster warehouse over the past week?"
    their_options:
      option A: "SHOW WAREHOUSES shows current clusters but not historical average"
      option B: "Query WAREHOUSE_EVENTS_HISTORY to calculate average from cluster start/stop events"
      option C: "Query WAREHOUSE_METERING_HISTORY and divide CREDITS_USED by the per-cluster hourly rate"
      option D: "Both B and C provide methods to estimate this"
    correct Answer: "D"
    explanation: >
      D is correct because both approaches provide methods to estimate average cluster count.
      B uses actual event timestamps to compute average. C divides total credits by the
      per-cluster rate to infer the average number of clusters. A only provides current
      state. Combining B and C gives the most accurate picture.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "226"
    question: "What is the difference between a warehouse being 'Suspended' and 'Dropped'?"
    their_options:
      option A: "There is no difference"
      option B: "Suspended means compute is released but the warehouse definition exists; Dropped means the warehouse is deleted entirely"
      option C: "Suspended warehouses still consume credits; Dropped warehouses do not"
      option D: "Dropped warehouses can be resumed; Suspended warehouses cannot"
    correct Answer: "B"
    explanation: >
      B is correct. A suspended warehouse has released its compute resources (no credits
      consumed) but still exists as an object that can be resumed. A dropped warehouse is
      deleted and its definition is removed. A is wrong. C is wrong because suspended
      warehouses do not consume credits. D reverses the correct behavior.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "227"
    question: "Can you UNDROP a warehouse?"
    their_options:
      option A: "Yes, using UNDROP WAREHOUSE <name>"
      option B: "No, dropped warehouses cannot be recovered"
      option C: "Yes, but only within 24 hours"
      option D: "Yes, but only with ACCOUNTADMIN role"
    correct Answer: "A"
    explanation: >
      A is correct because Snowflake supports UNDROP WAREHOUSE to recover a recently dropped
      warehouse. B is wrong because UNDROP is supported. C is wrong because the retention
      period is based on account settings, not a fixed 24 hours. D is partially correctâ€”
      you need ownership or higher privileges, but UNDROP itself is available.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "228"
    question: "Your company's Snowflake bill shows unexpected cloud services credits. Which query helps investigate?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME, SUM(CREDITS_USED_CLOUD_SERVICES) AS CS_CREDITS
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('day', -30, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
        ORDER BY CS_CREDITS DESC;
      option B: "SHOW CLOUD SERVICES CREDITS;"
      option C: "SELECT * FROM CLOUD_BILLING_HISTORY;"
      option D: "DESCRIBE ACCOUNT CLOUD_SERVICES;"
    correct Answer: "A"
    explanation: >
      A is correct because it queries CREDITS_USED_CLOUD_SERVICES from
      WAREHOUSE_METERING_HISTORY, grouping by warehouse to identify which warehouses
      drive the most cloud services costs. B, C, and D are not valid commands or views.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "229"
    question: "A team wants to prevent analysts from running queries longer than 5 minutes on their shared warehouse. What is the best approach?"
    their_options:
      option A: "ALTER WAREHOUSE ANALYTICS_WH SET STATEMENT_TIMEOUT_IN_SECONDS = 300;"
      option B: "ALTER WAREHOUSE ANALYTICS_WH SET AUTO_SUSPEND = 300;"
      option C: "Create a resource monitor with 5-minute frequency"
      option D: "Set MAX_CONCURRENCY_LEVEL = 1"
    correct Answer: "A"
    explanation: >
      A is correct because setting STATEMENT_TIMEOUT_IN_SECONDS to 300 (5 minutes) on the
      warehouse will automatically cancel any query that runs longer than 5 minutes. B
      controls auto-suspension, not query timeout. C does not limit individual query runtime.
      D limits concurrency, not duration.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "230"
    question: "If STATEMENT_TIMEOUT_IN_SECONDS is set to 300 at the account level and 600 at the warehouse level, which value applies?"
    their_options:
      option A: "300 (account level overrides)"
      option B: "600 (warehouse level overrides)"
      option C: "The more restrictive (lower non-zero) value: 300"
      option D: "The less restrictive (higher) value: 600"
    correct Answer: "C"
    explanation: >
      C is correct because when STATEMENT_TIMEOUT_IN_SECONDS is set at multiple levels, the
      most restrictive (lowest non-zero) value takes effect. With 300 at account and 600 at
      warehouse, 300 applies. A and C both result in 300, but C provides the correct
      explanation. B and D are wrong.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "231"
    question: "Which ACCOUNT_USAGE view tracks login attempts and can help correlate with warehouse activity?"
    their_options:
      option A: "ACCESS_HISTORY"
      option B: "LOGIN_HISTORY"
      option C: "SESSION_HISTORY"
      option D: "USER_ACTIVITY_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because LOGIN_HISTORY tracks all login attempts (successful and failed)
      with timestamps, which can be correlated with warehouse activity to understand usage
      patterns. A tracks object access. C and D are not standard ACCOUNT_USAGE views.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "232"
    question: "How does the ECONOMY scaling policy for multi-cluster warehouses affect monitoring?"
    their_options:
      option A: "It adds clusters faster, so monitoring shows more frequent scale events"
      option B: "It conserves credits by adding clusters only when load is sustained, resulting in higher AVG_QUEUED_LOAD but lower credit consumption"
      option C: "It has no effect on monitoring metrics"
      option D: "It prevents any scaling, keeping cluster count fixed"
    correct Answer: "B"
    explanation: >
      B is correct because ECONOMY mode waits until load is sustained before adding clusters,
      so monitoring will show higher AVG_QUEUED_LOAD (more queuing) but lower total credit
      consumption compared to STANDARD mode. A describes STANDARD policy. C is wrong because
      scaling policy significantly affects metrics. D is wrong because it does allow scaling.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "233"
    question: "What does it mean if a warehouse shows CREDITS_USED = 0 in WAREHOUSE_METERING_HISTORY for a particular hour but the warehouse was in 'Started' state?"
    their_options:
      option A: "This cannot happen; started warehouses always consume credits"
      option B: "The warehouse may have been started and suspended within the same hour with very minimal usage rounded down, or it's a data latency issue"
      option C: "The warehouse was in error state"
      option D: "Credits are being tracked in a different view"
    correct Answer: "B"
    explanation: >
      B is correct. This can happen due to rounding in the metering view, very brief activity
      that results in negligible credit consumption, or data latency in the ACCOUNT_USAGE
      views. A is generally true but edge cases exist. C is wrong. D is wrong because
      WAREHOUSE_METERING_HISTORY is the primary view for this data.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "234"
    question: "Which approach provides the most granular view of warehouse costs by application or team?"
    their_options:
      option A: "Assign different warehouses per team"
      option B: "Use QUERY_TAG to tag queries by application/team and correlate with execution time and warehouse size"
      option C: "Use resource monitors per team"
      option D: "Both A and B provide different levels of granularity and can be combined"
    correct Answer: "D"
    explanation: >
      D is correct. Separate warehouses per team (A) provide clean warehouse-level cost
      attribution. QUERY_TAGs (B) provide query-level attribution within shared warehouses.
      Combining both gives the most comprehensive view. A alone lacks intra-warehouse detail.
      B alone lacks the simplicity of per-warehouse billing. C only provides alerts, not
      detailed attribution.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "235"
    question: "What happens when a resource monitor at the warehouse level AND an account-level resource monitor both trigger SUSPEND simultaneously?"
    their_options:
      option A: "Only the warehouse-level action takes effect"
      option B: "Only the account-level action takes effect"
      option C: "Both actions take effect; the warehouse is suspended by whichever triggers first"
      option D: "The system throws an error due to conflicting actions"
    correct Answer: "C"
    explanation: >
      C is correct because both resource monitors operate independently. Whichever trigger
      condition is met first will suspend the warehouse. They do not conflictâ€”both are
      evaluated separately. A and B are wrong because neither takes exclusive precedence.
      D is wrong because there is no error from having multiple monitors.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "236"
    question: "How can you configure a resource monitor to reset its credit tracking on the first day of each calendar month?"
    their_options:
      option A: "Set FREQUENCY = MONTHLY and START_TIMESTAMP to the first day of the current month"
      option B: "Set FREQUENCY = MONTHLY; it automatically aligns to calendar months"
      option C: "Set FREQUENCY = CALENDAR_MONTHLY"
      option D: "Resource monitors cannot align to calendar months"
    correct Answer: "A"
    explanation: >
      A is correct because by setting START_TIMESTAMP to the first day of the current month
      and FREQUENCY = MONTHLY, the quota resets on the 1st of each subsequent month. B is
      wrong because MONTHLY aligns to the START_TIMESTAMP, not automatically to calendar
      months. C is wrong because CALENDAR_MONTHLY is not a valid frequency. D is wrong
      because it can be achieved via START_TIMESTAMP.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "237"
    question: "What is the purpose of monitoring QUEUED_REPAIR_TIME in QUERY_HISTORY?"
    their_options:
      option A: "Time spent repairing corrupted data"
      option B: "Time spent waiting for the warehouse to repair after an internal error"
      option C: "Time spent in the queue due to a warehouse being repaired after a failure"
      option D: "This column does not exist in QUERY_HISTORY"
    correct Answer: "D"
    explanation: >
      D is correct because QUEUED_REPAIR_TIME is not a standard column in QUERY_HISTORY.
      The actual queue-related columns are QUEUED_PROVISIONING_TIME, QUEUED_OVERLOAD_TIME,
      and QUEUED_BLOCKED_TIME. A, B, and C describe a non-existent metric.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "238"
    question: "Which monitoring action should you take if you observe a warehouse with consistently low AVG_RUNNING but high CREDITS_USED?"
    their_options:
      option A: "The warehouse is performing optimally"
      option B: "The warehouse is too large for its workloadâ€”consider downsizing to reduce credits while maintaining low queue times"
      option C: "Add more clusters"
      option D: "Increase AUTO_SUSPEND time"
    correct Answer: "B"
    explanation: >
      B is correct because low AVG_RUNNING (few concurrent queries) with high CREDITS_USED
      means the warehouse is likely oversizedâ€”consuming many credits per hour but not fully
      utilizing its capacity. Downsizing would maintain performance while reducing cost.
      A is wrong. C would increase costs further. D would also increase costs.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "239"
    question: "What is the correct way to view all parameters set on a warehouse?"
    their_options:
      option A: "SHOW PARAMETERS IN WAREHOUSE my_wh;"
      option B: "DESCRIBE WAREHOUSE my_wh PARAMETERS;"
      option C: "SELECT * FROM WAREHOUSE_PARAMETERS WHERE NAME = 'my_wh';"
      option D: "LIST PARAMETERS FOR WAREHOUSE my_wh;"
    correct Answer: "A"
    explanation: >
      A is correct because SHOW PARAMETERS IN WAREHOUSE <name> displays all parameters
      configured for that warehouse including STATEMENT_TIMEOUT_IN_SECONDS,
      STATEMENT_QUEUED_TIMEOUT_IN_SECONDS, MAX_CONCURRENCY_LEVEL, etc. B, C, and D are
      not valid Snowflake commands.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "240"
    question: "How can you programmatically check if a warehouse is currently running or suspended?"
    their_options:
      option A: "SELECT SYSTEM$WAREHOUSE_STATUS('MY_WH');"
      option B: "SELECT \"state\" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())) after running SHOW WAREHOUSES LIKE 'MY_WH';"
      option C: "SELECT STATE FROM WAREHOUSES WHERE NAME = 'MY_WH';"
      option D: "CALL WAREHOUSE_STATE('MY_WH');"
    correct Answer: "B"
    explanation: >
      B is correct because you can run SHOW WAREHOUSES LIKE 'MY_WH' and then use
      RESULT_SCAN to access the results programmatically, extracting the state column.
      A is not a valid system function. C does not use valid view syntax. D is not a
      valid procedure.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "241"
    question: "What happens to a resource monitor when its assigned warehouse is dropped?"
    their_options:
      option A: "The resource monitor is automatically dropped"
      option B: "The resource monitor remains but no longer tracks anything for that warehouse"
      option C: "The resource monitor continues to consume credits"
      option D: "An error is thrown preventing the warehouse from being dropped"
    correct Answer: "B"
    explanation: >
      B is correct because dropping a warehouse does not drop its associated resource monitor.
      The monitor remains but has nothing to track for that warehouse. It can be reassigned
      to another warehouse. A is wrong. C is wrong because monitors do not consume credits.
      D is wrong because warehouses can be dropped regardless of monitor assignment.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "242"
    question: "Which query identifies warehouses that have never been used (no queries executed)?"
    their_options:
      option A: >
        SELECT W.WAREHOUSE_NAME
        FROM (SELECT DISTINCT WAREHOUSE_NAME FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY) W
        LEFT JOIN (SELECT DISTINCT WAREHOUSE_NAME FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY) Q
        ON W.WAREHOUSE_NAME = Q.WAREHOUSE_NAME
        WHERE Q.WAREHOUSE_NAME IS NULL;
      option B: "SHOW WAREHOUSES WHERE USED = FALSE;"
      option C: "SELECT * FROM UNUSED_WAREHOUSES;"
      option D: "SELECT WAREHOUSE_NAME FROM WAREHOUSE_HISTORY WHERE QUERY_COUNT = 0;"
    correct Answer: "A"
    explanation: >
      A is correct because it uses a LEFT JOIN to find warehouses that appear in metering
      history (were running) but have no entries in query history (no queries executed). B
      is not valid syntax. C is not a real view. D is not a real view or valid column.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "243"
    question: "What is the significance of the START_TIMESTAMP property in a resource monitor?"
    their_options:
      option A: "It defines when credit tracking begins and determines the reset schedule"
      option B: "It defines when the resource monitor was created"
      option C: "It defines the earliest time the warehouse can be started"
      option D: "It defines the start of the billing period for the account"
    correct Answer: "A"
    explanation: >
      A is correct because START_TIMESTAMP defines when the resource monitor begins tracking
      credit usage and sets the anchor date for periodic resets based on the FREQUENCY setting.
      B is close but the creation timestamp is different from START_TIMESTAMP. C is wrong.
      D is wrong.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "244"
    question: "Can a resource monitor have triggers at both below and above 100%?"
    their_options:
      option A: "No, all triggers must be below 100%"
      option B: "Yes, you can have triggers at percentages like 80%, 100%, and 120% for different actions"
      option C: "Only NOTIFY triggers can be above 100%"
      option D: "Only SUSPEND_IMMEDIATE can be above 100%"
    correct Answer: "B"
    explanation: >
      B is correct because you can set triggers at any percentage including above 100%. This
      is useful because credit checks are periodic, and usage can exceed 100% between checks.
      A is wrong. C and D incorrectly restrict which action types can be above 100%.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "245"
    question: "What column in WAREHOUSE_EVENTS_HISTORY shows the reason for a warehouse event?"
    their_options:
      option A: "EVENT_REASON"
      option B: "EVENT_NAME"
      option C: "EVENT_STATE"
      option D: "TIMESTAMP"
    correct Answer: "A"
    explanation: >
      A is correct because EVENT_REASON in WAREHOUSE_EVENTS_HISTORY provides context for why
      an event occurred (e.g., auto-suspend due to inactivity, resume triggered by user query,
      scaling due to load). B shows the event type. C shows the resulting state. D shows when
      the event occurred.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "246"
    question: "A newly resumed warehouse shows slow query performance initially. What monitoring metric explains this?"
    their_options:
      option A: "High CREDITS_USED"
      option B: "High QUEUED_PROVISIONING_TIME and low PERCENTAGE_SCANNED_FROM_CACHE"
      option C: "High AVG_QUEUED_LOAD"
      option D: "High ROWS_PRODUCED"
    correct Answer: "B"
    explanation: >
      B is correct because a newly resumed warehouse has a cold local disk cache (low
      PERCENTAGE_SCANNED_FROM_CACHE), meaning data must be read from remote storage. Initial
      queries also experience QUEUED_PROVISIONING_TIME while the warehouse starts. This is
      the 'cold start' effect. A, C, and D do not explain the initial slow performance.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "247"
    question: "Which column indicates the Snowflake warehouse credit price multiplier based on warehouse size?"
    their_options:
      option A: "There is no direct column; you calculate it from WAREHOUSE_SIZE (each size doubles: XS=1, S=2, M=4...)"
      option B: "CREDIT_MULTIPLIER in SHOW WAREHOUSES"
      option C: "PRICE_PER_HOUR in WAREHOUSE_METERING_HISTORY"
      option D: "COST_FACTOR in ACCOUNT_USAGE"
    correct Answer: "A"
    explanation: >
      A is correct. There is no direct credit multiplier column. You must know the mapping:
      X-Small=1, Small=2, Medium=4, Large=8, XL=16, 2XL=32, etc. and calculate based on
      WAREHOUSE_SIZE. B, C, and D reference non-existent columns.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "248"
    question: "How can Snowflake Alerts be used for warehouse monitoring?"
    their_options:
      option A: "Alerts can only monitor data changes"
      option B: "Alerts can run SQL conditions against monitoring views and trigger notifications when thresholds are exceeded"
      option C: "Alerts replace resource monitors entirely"
      option D: "Alerts can only be used with external tools"
    correct Answer: "B"
    explanation: >
      B is correct because Snowflake Alerts (CREATE ALERT) allow you to define SQL-based
      conditions that query any view, including monitoring views like WAREHOUSE_METERING_HISTORY
      or QUERY_HISTORY, and trigger actions (e.g., calling stored procedures, sending
      notifications) when conditions are met. A is too limited. C is wrong; they complement
      resource monitors. D is wrong because alerts are native Snowflake features.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "249"
    question: "Which monitoring approach helps identify 'zombie' warehouses (warehouses that exist but are never used)?"
    their_options:
      option A: "Check SHOW WAREHOUSES for warehouses in Suspended state"
      option B: "Cross-reference warehouse list from SHOW WAREHOUSES with QUERY_HISTORY and WAREHOUSE_METERING_HISTORY for any activity in the last 90 days"
      option C: "Check resource monitor alerts"
      option D: "Query LOGIN_HISTORY for inactive users"
    correct Answer: "B"
    explanation: >
      B is correct because comparing the list of existing warehouses against activity in
      QUERY_HISTORY and WAREHOUSE_METERING_HISTORY identifies warehouses with no recent
      use. These 'zombie' warehouses can be dropped to reduce clutter. A only shows current
      state, not usage history. C does not identify unused warehouses. D tracks users, not
      warehouses.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "250"
    question: "What is the correct syntax to drop a resource monitor?"
    their_options:
      option A: "DROP RESOURCE MONITOR my_monitor;"
      option B: "DELETE RESOURCE MONITOR my_monitor;"
      option C: "REMOVE RESOURCE MONITOR my_monitor;"
      option D: "ALTER RESOURCE MONITOR my_monitor DROP;"
    correct Answer: "A"
    explanation: >
      A is correct because DROP RESOURCE MONITOR is the standard DDL command to remove a
      resource monitor. B, C, and D are not valid Snowflake syntax for this operation.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect
    
     - Question No: "251"
    question: "What is the difference between INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY and ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY in terms of invocation?"
    their_options:
      option A: "Both are queried identically as standard views"
      option B: "INFORMATION_SCHEMA version is a table function requiring TABLE() syntax; ACCOUNT_USAGE version is a standard view"
      option C: "ACCOUNT_USAGE version is a table function; INFORMATION_SCHEMA version is a view"
      option D: "Both require TABLE() syntax"
    correct Answer: "B"
    explanation: >
      B is correct because in INFORMATION_SCHEMA, WAREHOUSE_METERING_HISTORY is a table
      function and must be invoked using TABLE(INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY(...)).
      In ACCOUNT_USAGE, it is a standard view queried with normal SELECT syntax. A is wrong.
      C reverses them. D is wrong.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "252"
    question: "Which parameter on a resource monitor defines when tracking starts?"
    their_options:
      option A: "BEGIN_TIMESTAMP"
      option B: "START_TIMESTAMP"
      option C: "TRACKING_START"
      option D: "MONITOR_START"
    correct Answer: "B"
    explanation: >
      B is correct. START_TIMESTAMP defines when the resource monitor begins tracking credits.
      It can be set to IMMEDIATELY or a specific timestamp. A, C, and D are not valid
      resource monitor parameters.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "253"
    question: "A warehouse shows 0 credits in INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY but 50 credits in ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY for the same time period. Why?"
    their_options:
      option A: "The data is corrupted"
      option B: "INFORMATION_SCHEMA only retains 14 days; if the period is older than 14 days, it shows no data, while ACCOUNT_USAGE retains 365 days"
      option C: "ACCOUNT_USAGE always shows higher numbers"
      option D: "INFORMATION_SCHEMA only tracks cloud services credits"
    correct Answer: "B"
    explanation: >
      B is correct because if you query a time period older than 14 days, INFORMATION_SCHEMA
      will have no data (or incomplete data) while ACCOUNT_USAGE retains up to 365 days.
      A is wrong. C is wrong; they should show the same data within the retention window.
      D is wrong.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "254"
    question: "Which command resumes a suspended warehouse?"
    their_options:
      option A: "ALTER WAREHOUSE my_wh RESUME;"
      option B: "START WAREHOUSE my_wh;"
      option C: "RESUME WAREHOUSE my_wh;"
      option D: "ALTER WAREHOUSE my_wh START;"
    correct Answer: "A"
    explanation: >
      A is correct because ALTER WAREHOUSE ... RESUME is the valid DDL to manually resume
      a suspended warehouse. B, C, and D are not valid Snowflake syntax.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "255"
    question: "Which monitoring view helps determine if a warehouse would benefit from enabling the Query Acceleration Service?"
    their_options:
      option A: "WAREHOUSE_METERING_HISTORY"
      option B: "QUERY_HISTORY with SYSTEM$ESTIMATE_QUERY_ACCELERATION for specific queries"
      option C: "WAREHOUSE_LOAD_HISTORY"
      option D: "WAREHOUSE_EVENTS_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because QUERY_HISTORY identifies long-running queries with large scan
      operations, and SYSTEM$ESTIMATE_QUERY_ACCELERATION evaluates specific query IDs for
      QAS eligibility and estimated improvement. A tracks credits. C tracks load. D tracks
      events. None of these assess QAS eligibility.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "256"
    question: "What is the maximum retention period for QUERY_HISTORY in INFORMATION_SCHEMA?"
    their_options:
      option A: "14 days"
      option B: "7 days"
      option C: "30 days"
      option D: "365 days"
    correct Answer: "B"
    explanation: >
      B is correct because the INFORMATION_SCHEMA QUERY_HISTORY table function retains data
      for up to 7 days. A (14 days) applies to some other INFORMATION_SCHEMA views like
      WAREHOUSE_METERING_HISTORY. C and D are not applicable to INFORMATION_SCHEMA.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "257"
    question: "What does monitoring the PARTITIONS_SCANNED vs PARTITIONS_TOTAL ratio tell you?"
    their_options:
      option A: "How much storage the table uses"
      option B: "How effective micro-partition pruning isâ€”lower ratio means better pruning and less data scanned"
      option C: "How many partitions are corrupted"
      option D: "The total number of tables in the database"
    correct Answer: "B"
    explanation: >
      B is correct. A low PARTITIONS_SCANNED/PARTITIONS_TOTAL ratio indicates effective
      pruningâ€”Snowflake is skipping irrelevant partitions based on query predicates. This
      means less data needs to be read by the warehouse, improving performance and reducing
      credit consumption. A is about storage. C is incorrect. D is irrelevant.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "258"
    question: "A warehouse is running at full capacity. What TWO monitoring indicators would you expect to see? (Select TWO)"
    their_options:
      option A: "AVG_RUNNING close to the maximum concurrency of the warehouse"
      option B: "AVG_QUEUED_LOAD > 0 (queries are being queued)"
      option C: "CREDITS_USED = 0"
      option D: "The warehouse is in Suspended state"
      option E: "COMPILATION_TIME = 0 for all queries"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. A warehouse at full capacity shows AVG_RUNNING near its maximum
      concurrency (A) and queries queuing because no more slots are available (B). C is
      wrong because active warehouses consume credits. D contradicts running state. E is
      unrelated to capacity.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "259"
    question: "How can you view the SQL text of the most recent query executed on a specific warehouse?"
    their_options:
      option A: >
        SELECT QUERY_TEXT FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY_BY_WAREHOUSE('MY_WH'))
        ORDER BY START_TIME DESC LIMIT 1;
      option B: >
        SELECT QUERY_TEXT
        FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(WAREHOUSE_NAME => 'MY_WH'))
        ORDER BY START_TIME DESC LIMIT 1;
      option C: "SHOW LAST QUERY ON WAREHOUSE MY_WH;"
      option D: "SELECT LAST_QUERY_TEXT() FROM WAREHOUSE MY_WH;"
    correct Answer: "B"
    explanation: >
      B is correct because it calls the QUERY_HISTORY table function filtered by warehouse
      name, orders by START_TIME descending, and limits to 1 to get the most recent query.
      A references a non-existent function. C and D are not valid Snowflake syntax.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "260"
    question: "What is the impact of setting MAX_CONCURRENCY_LEVEL too low on warehouse monitoring metrics?"
    their_options:
      option A: "No impact"
      option B: "Higher AVG_QUEUED_LOAD because more queries are forced to wait, and potentially higher total execution time due to serialization"
      option C: "Lower CREDITS_USED because fewer queries run"
      option D: "Higher COMPILATION_TIME"
    correct Answer: "B"
    explanation: >
      B is correct because a low MAX_CONCURRENCY_LEVEL means fewer queries run simultaneously,
      causing more to queue (higher AVG_QUEUED_LOAD) and potentially increasing total elapsed
      time. A is wrong because it significantly impacts metrics. C is wrong because total
      runtime may actually increase. D is wrong because compilation is not affected by
      concurrency settings.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "261"
    question: "What monitoring data should you analyze before right-sizing a warehouse? (Select THREE)"
    their_options:
      option A: "WAREHOUSE_LOAD_HISTORY (average load and queuing)"
      option B: "QUERY_HISTORY (spillage, execution time, scan efficiency)"
      option C: "WAREHOUSE_METERING_HISTORY (credit consumption)"
      option D: "LOGIN_HISTORY (user logins)"
      option E: "DATA_TRANSFER_HISTORY (data transfers)"
    correct Answer: "A, B, C"
    explanation: >
      A, B, and C are correct. Right-sizing requires understanding load patterns (A),
      individual query performance including spillage and scan efficiency (B), and total
      credit consumption (C). D (login history) does not help with sizing. E (data transfers)
      is irrelevant to warehouse sizing decisions.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "262"
    question: "What happens if you alter a resource monitor to change its FREQUENCY while it is actively tracking credits?"
    their_options:
      option A: "The change takes effect immediately, resetting the current period's credit tracking"
      option B: "The change takes effect at the start of the next period"
      option C: "The command fails because the monitor is active"
      option D: "The current period's credits are preserved, and the new frequency begins from the current START_TIMESTAMP"
    correct Answer: "A"
    explanation: >
      A is correct because altering the frequency of a resource monitor resets the credit
      tracking for the current period. The new frequency begins tracking from the updated
      settings. B is wrong because it takes effect immediately. C is wrong because the
      command succeeds. D is partially correct but the credit counter does reset.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "263"
    question: "Which query shows the ratio of cloud services credits to compute credits per warehouse?"
    their_options:
      option A: >
        SELECT WAREHOUSE_NAME,
        SUM(CREDITS_USED) AS COMPUTE_CREDITS,
        SUM(CREDITS_USED_CLOUD_SERVICES) AS CS_CREDITS,
        ROUND(SUM(CREDITS_USED_CLOUD_SERVICES) / NULLIF(SUM(CREDITS_USED), 0) * 100, 2) AS CS_PERCENTAGE
        FROM SNOWFLAKE.ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY
        WHERE START_TIME >= DATEADD('month', -1, CURRENT_TIMESTAMP())
        GROUP BY WAREHOUSE_NAME
        ORDER BY CS_PERCENTAGE DESC;
      option B: "SHOW CLOUD_SERVICES_RATIO;"
      option C: "SELECT CS_RATIO FROM WAREHOUSE_COSTS;"
      option D: "DESCRIBE ACCOUNT CLOUD_SERVICES;"
    correct Answer: "A"
    explanation: >
      A is correct because it calculates the percentage of cloud services credits relative
      to compute credits for each warehouse, identifying warehouses where cloud services
      are a disproportionate cost. B, C, and D are not valid commands or views.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "264"
    question: "What is the purpose of setting END_TIMESTAMP on a resource monitor?"
    their_options:
      option A: "To set when the resource monitor stops tracking credits and becomes inactive"
      option B: "To set the end of each monitoring period"
      option C: "To set when the warehouse should be dropped"
      option D: "END_TIMESTAMP is not a valid resource monitor property"
    correct Answer: "A"
    explanation: >
      A is correct because END_TIMESTAMP defines when the resource monitor becomes inactive
      and stops tracking credits. It is optionalâ€”if not set, the monitor runs indefinitely.
      B is wrong because the period end is determined by FREQUENCY. C is wrong. D is wrong
      because END_TIMESTAMP is a valid property.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "265"
    question: "How can you identify whether a slow query is caused by the warehouse being undersized or by poor query optimization?"
    their_options:
      option A: "If the query shows high spillage â†’ undersized warehouse. If the query shows full table scans on large tables â†’ poor optimization."
      option B: "You cannot distinguish between the two"
      option C: "All slow queries are caused by undersized warehouses"
      option D: "Check WAREHOUSE_METERING_HISTORY only"
    correct Answer: "A"
    explanation: >
      A is correct. High BYTES_SPILLED_TO_LOCAL_STORAGE or BYTES_SPILLED_TO_REMOTE_STORAGE
      indicates the warehouse lacks memory (undersized). High BYTES_SCANNED with low pruning
      efficiency indicates poor query optimization (missing filters, no clustering). B is
      wrong. C is an oversimplification. D does not provide query-level diagnostics.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "266"
    question: "What is the default AUTO_RESUME setting for a newly created warehouse?"
    their_options:
      option A: "TRUE"
      option B: "FALSE"
      option C: "It depends on the warehouse size"
      option D: "It depends on the Snowflake edition"
    correct Answer: "A"
    explanation: >
      A is correct because the default AUTO_RESUME value is TRUE, meaning the warehouse will
      automatically start when a query is submitted to it. B, C, and D are incorrect.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "267"
    question: "How frequently does Snowflake check resource monitor thresholds?"
    their_options:
      option A: "Every second"
      option B: "Every minute"
      option C: "Approximately every 15 minutes (not exact; depends on internal scheduling)"
      option D: "Once per hour"
    correct Answer: "C"
    explanation: >
      C is correct because Snowflake checks resource monitor thresholds periodically,
      approximately every 15 minutes, but the exact frequency is not guaranteed. This is
      why credit usage can overshoot a threshold between checks. A and B are too frequent.
      D is too infrequent.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "268"
    question: "Which monitoring approach is best for identifying seasonal trends in warehouse usage?"
    their_options:
      option A: "Query WAREHOUSE_METERING_HISTORY aggregated by month over the past year from ACCOUNT_USAGE"
      option B: "Check INFORMATION_SCHEMA views daily"
      option C: "Use SHOW WAREHOUSES"
      option D: "Review resource monitor alerts"
    correct Answer: "A"
    explanation: >
      A is correct because ACCOUNT_USAGE provides up to 365 days of data, enabling year-over-year
      and seasonal analysis when aggregated by month or week. B only has 14 days of data.
      C shows current state only. D only shows threshold alerts, not trends.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "269"
    question: "A company uses 10 warehouses with an average monthly consumption of 5,000 credits total. Cloud services credits are 800 per month. How many cloud services credits are actually billed?"
    their_options:
      option A: "800 credits"
      option B: "300 credits (800 - 10% of 5000)"
      option C: "0 credits (all covered by the 10% adjustment)"
      option D: "500 credits"
    correct Answer: "B"
    explanation: >
      B is correct. The 10% adjustment waives cloud services credits up to 10% of total
      compute credits. 10% Ã— 5,000 = 500 credits waived. Total cloud services = 800.
      Billed = 800 - 500 = 300 credits. A does not account for the adjustment. C
      incorrectly assumes all are waived. D is an incorrect calculation.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "270"
    question: "What is the key monitoring difference between serverless tasks and user-managed tasks?"
    their_options:
      option A: "Serverless tasks consume credits from a Snowflake-managed pool; user-managed tasks consume credits from a specified virtual warehouse"
      option B: "There is no monitoring difference"
      option C: "User-managed tasks cannot be monitored"
      option D: "Serverless tasks do not consume credits"
    correct Answer: "A"
    explanation: >
      A is correct. Serverless tasks use Snowflake-managed compute resources, and their
      credits appear in the serverless metering views. User-managed tasks use a specified
      warehouse, and their credits appear in WAREHOUSE_METERING_HISTORY. B is wrong because
      they appear in different views. C is wrong. D is wrong because serverless tasks consume
      serverless credits.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "271"
    question: "How can you verify that a resource monitor trigger has fired?"
    their_options:
      option A: "Query SNOWFLAKE.ACCOUNT_USAGE.RESOURCE_MONITORS for NOTIFY_USERS or check notification history"
      option B: "Resource monitor triggers leave no trace"
      option C: "Check QUERY_HISTORY for the trigger event"
      option D: "Run SHOW RESOURCE MONITORS and check the USED_CREDITS vs CREDIT_QUOTA ratio"
    correct Answer: "D"
    explanation: >
      D is correct. SHOW RESOURCE MONITORS shows the current credit usage relative to the
      quota. If USED_CREDITS is past a trigger threshold, that trigger has fired. A provides
      monitor details but the most direct check is D. B is wrong because triggers are
      trackable. C is wrong because triggers are not in QUERY_HISTORY.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "272"
    question: "What is the purpose of the INITIALLY_SUSPENDED parameter when creating a warehouse?"
    their_options:
      option A: "The warehouse is created in a suspended state and does not start consuming credits immediately"
      option B: "The warehouse is paused after the first query"
      option C: "The warehouse cannot be resumed for 24 hours"
      option D: "The warehouse is created and immediately dropped"
    correct Answer: "A"
    explanation: >
      A is correct because INITIALLY_SUSPENDED = TRUE creates the warehouse in a suspended
      state. It will not start (and consume credits) until explicitly resumed or until a
      query triggers AUTO_RESUME. This is useful for provisioning warehouses without
      immediate cost. B, C, and D are incorrect.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "273"
    question: "Which query helps detect potential data loading bottlenecks related to warehouse performance?"
    their_options:
      option A: >
        SELECT QUERY_ID, QUERY_TEXT, WAREHOUSE_NAME, EXECUTION_TIME,
        ROWS_INSERTED, BYTES_SCANNED
        FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY
        WHERE QUERY_TYPE = 'COPY'
        AND EXECUTION_TIME > 60000
        AND START_TIME >= DATEADD('day', -7, CURRENT_TIMESTAMP())
        ORDER BY EXECUTION_TIME DESC;
      option B: "SHOW COPY HISTORY;"
      option C: "SELECT * FROM LOADING_BOTTLENECKS;"
      option D: "DESCRIBE COPY PERFORMANCE;"
    correct Answer: "A"
    explanation: >
      A is correct because it queries QUERY_HISTORY for COPY operations taking over 60
      seconds, showing the warehouse used and data volume. This identifies loading queries
      that may need a larger warehouse. B, C, and D are not valid for this analysis.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "274"
    question: "If a warehouse is resized from Medium to X-Large while running, what is the credit impact?"
    their_options:
      option A: "4 credits/hour changes to 16 credits/hour immediately"
      option B: "There is a brief transition period where both old and new nodes may be active, then the new rate (16 credits/hour) applies"
      option C: "The medium rate continues until the end of the hour"
      option D: "The resize is free of charge"
    correct Answer: "B"
    explanation: >
      B is correct. During resizing, existing nodes (Medium = 4 credits/hour) continue to
      run while new nodes are provisioned. Once the resize completes, the new rate (X-Large
      = 16 credits/hour) applies. There may be a brief overlap. A is oversimplified. C is
      wrong because billing changes with the resize. D is wrong.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "275"
    question: "What type of notifications does Snowflake send for resource monitor NOTIFY triggers?"
    their_options:
      option A: "SMS only"
      option B: "Slack messages"
      option C: "Email notifications to Account Administrators who have enabled notifications, and in-app web UI notifications"
      option D: "Push notifications to mobile devices"
    correct Answer: "C"
    explanation: >
      C is correct. Resource monitor NOTIFY triggers send email notifications to Account
      Administrators who have opted in to receive them, and display notifications in the
      Snowsight web UI. A, B, and D are not the default notification channels for resource
      monitors.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "276"
    question: "Which QUERY_HISTORY column helps identify queries that produce Cartesian products?"
    their_options:
      option A: "ROWS_PRODUCED significantly exceeding the input table sizes"
      option B: "CARTESIAN_FLAG = TRUE"
      option C: "JOIN_TYPE = 'CROSS'"
      option D: "QUERY_TYPE = 'CARTESIAN'"
    correct Answer: "A"
    explanation: >
      A is correct. While there is no explicit Cartesian flag in QUERY_HISTORY, a dramatically
      high ROWS_PRODUCED relative to source table sizes indicates an unintended Cartesian
      product (cross join). The Query Profile in Snowsight also highlights exploding joins.
      B, C, and D are not actual columns or values.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "277"
    question: "What monitoring data is lost when you downgrade from Enterprise to Standard edition?"
    their_options:
      option A: "All monitoring data"
      option B: "Multi-cluster warehouse monitoring data, since multi-cluster warehouses are not supported in Standard"
      option C: "No monitoring data is lost, but multi-cluster features become unavailable going forward"
      option D: "Resource monitor data"
    correct Answer: "C"
    explanation: >
      C is correct. Historical monitoring data in ACCOUNT_USAGE is preserved regardless of
      edition changes. However, multi-cluster warehouse features become unavailable, so you
      cannot create or scale multi-cluster warehouses going forward. A and D are wrong because
      data is not deleted. B is misleading; historical data remains.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Architect

  - Question No: "278"
    question: "What is the role of the cloud services layer in warehouse monitoring?"
    their_options:
      option A: "It only stores monitoring data"
      option B: "It handles query parsing, compilation, optimization, metadata management, and authenticationâ€”activities tracked as cloud services credits"
      option C: "It executes queries on behalf of the warehouse"
      option D: "It manages data storage only"
    correct Answer: "B"
    explanation: >
      B is correct. The cloud services layer handles metadata operations, query parsing and
      compilation, optimization planning, access control, and other management functions.
      These activities consume cloud services credits, which are tracked separately from
      warehouse compute credits. A is too limited. C describes the warehouse layer. D
      describes the storage layer.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "279"
    question: "How can you check the current remaining credits on a resource monitor without running SHOW RESOURCE MONITORS?"
    their_options:
      option A: "Query SNOWFLAKE.ACCOUNT_USAGE.RESOURCE_MONITORS view"
      option B: "There is no alternative to SHOW RESOURCE MONITORS"
      option C: "Query INFORMATION_SCHEMA.RESOURCE_MONITORS"
      option D: "Check the Snowsight Admin > Resource Monitors page"
    correct Answer: "A"
    explanation: >
      A is correct because the ACCOUNT_USAGE.RESOURCE_MONITORS view provides historical and
      current resource monitor data that can be queried programmatically without using SHOW
      commands. B is wrong because alternatives exist. C is wrong because this view is in
      ACCOUNT_USAGE, not INFORMATION_SCHEMA. D is also valid via the UI but the question
      asks about a non-SHOW approach, and A is the SQL alternative.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "280"
    question: "Which monitoring metric is most useful for justifying a warehouse size increase to management?"
    their_options:
      option A: "Total CREDITS_USED"
      option B: "Average QUEUED_OVERLOAD_TIME per query and BYTES_SPILLED_TO_REMOTE_STORAGE"
      option C: "Number of users on the warehouse"
      option D: "WAREHOUSE_SIZE from SHOW WAREHOUSES"
    correct Answer: "B"
    explanation: >
      B is correct because high QUEUED_OVERLOAD_TIME shows queries waiting due to insufficient
      resources, and high spillage shows the warehouse lacks memory. These are concrete,
      performance-impacting metrics that justify an upgrade. A shows cost but not need. C is
      not a direct performance metric. D shows current size, not a justification.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "281"
    question: "What column in WAREHOUSE_LOAD_HISTORY shows queries blocked by transaction locks?"
    their_options:
      option A: "AVG_BLOCKED"
      option B: "AVG_LOCKED"
      option C: "AVG_QUEUED_BLOCKED"
      option D: "BLOCKED_QUERIES"
    correct Answer: "A"
    explanation: >
      A is correct because AVG_BLOCKED in WAREHOUSE_LOAD_HISTORY shows the average number
      of queries blocked by transaction locks. B, C, and D are not actual column names in
      this view.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "282"
    question: "A company wants to track which applications are consuming the most warehouse credits. What is the best approach?"
    their_options:
      option A: "Create separate warehouses per application"
      option B: "Use QUERY_TAG to tag queries by application name and aggregate execution time from QUERY_HISTORY"
      option C: "Both A and B, depending on the level of isolation needed"
      option D: "It is not possible to track by application"
    correct Answer: "C"
    explanation: >
      C is correct. Separate warehouses (A) provide the cleanest cost attribution per
      application. QUERY_TAG (B) allows tracking within shared warehouses. The best approach
      depends on whether applications need isolated compute or can share. D is wrong because
      both methods enable application-level tracking.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "283"
    question: "What does the is_default column in SHOW WAREHOUSES indicate?"
    their_options:
      option A: "Whether this is the account's default warehouse"
      option B: "Whether this is the default warehouse for the current user"
      option C: "Whether the warehouse uses default settings"
      option D: "Whether the warehouse was created with default parameters"
    correct Answer: "B"
    explanation: >
      B is correct because is_default indicates whether the warehouse is set as the default
      for the current user (via ALTER USER SET DEFAULT_WAREHOUSE). A is wrong because there
      is no single account-level default. C and D are wrong interpretations.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "284"
    question: "Which approach helps prevent runaway queries from consuming excessive warehouse credits?"
    their_options:
      option A: "Set STATEMENT_TIMEOUT_IN_SECONDS at the warehouse level"
      option B: "Set STATEMENT_QUEUED_TIMEOUT_IN_SECONDS to prevent infinite queuing"
      option C: "Set resource monitors with SUSPEND actions"
      option D: "All of the above work together to control credit consumption"
    correct Answer: "D"
    explanation: >
      D is correct because a comprehensive approach combines all three: STATEMENT_TIMEOUT
      prevents individual long-running queries (A), STATEMENT_QUEUED_TIMEOUT prevents
      infinite queuing (B), and resource monitors provide budget-level controls (C).
      Together, they create a multi-layered cost control strategy.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "285"
    question: "How does Snowflake's Query Profile help with warehouse right-sizing?"
    their_options:
      option A: "It directly recommends the optimal warehouse size"
      option B: "It shows operator-level details like scan efficiency, spillage, join strategies, and processing time that indicate whether a query needs more compute resources"
      option C: "It only shows the query text"
      option D: "It shows the warehouse configuration"
    correct Answer: "B"
    explanation: >
      B is correct because Query Profile provides detailed operator-level metrics that help
      determine if a query's performance issues are due to insufficient warehouse resources
      (spillage, processing bottlenecks) or query optimization issues (poor pruning, exploding
      joins). A is wrong; Snowflake does not auto-recommend sizes. C and D are too limited.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "286"
    question: "What is the credit consumption pattern of a multi-cluster warehouse with MIN_CLUSTER_COUNT = 2?"
    their_options:
      option A: "It always consumes credits for 2 clusters, even with zero load"
      option B: "It consumes credits for 2 clusters minimum when started, as MIN_CLUSTER_COUNT means at least 2 clusters are always running when the warehouse is active"
      option C: "It starts with 1 cluster and scales to 2 only under load"
      option D: "MIN_CLUSTER_COUNT only affects the initial startup"
    correct Answer: "B"
    explanation: >
      B is correct. With MIN_CLUSTER_COUNT = 2, when the warehouse is running, it always has
      at least 2 clusters active, consuming credits for both. During idle periods (if
      auto-suspended), no credits are consumed. A is misleading because credits are not
      consumed when suspended. C is wrong because MIN_CLUSTER_COUNT is enforced. D is wrong.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "287"
    question: "Which feature in Snowsight helps visually compare credit consumption across different warehouses?"
    their_options:
      option A: "The Admin > Warehouses page with usage graphs"
      option B: "The Data > Databases page"
      option C: "The Worksheets page"
      option D: "The Activity > Copy History page"
    correct Answer: "A"
    explanation: >
      A is correct because the Admin > Warehouses page in Snowsight displays usage graphs
      for each warehouse, allowing visual comparison of credit consumption. B shows database
      info. C is for SQL editing. D tracks copy operations.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataAnalyst

  - Question No: "288"
    question: "What is a good monitoring practice for serverless warehouses used by Snowflake Tasks?"
    their_options:
      option A: "Set resource monitors on the serverless warehouses"
      option B: "Monitor SERVERLESS_TASK_HISTORY and METERING_HISTORY for serverless credit consumption"
      option C: "Serverless warehouses cannot be monitored"
      option D: "Check WAREHOUSE_METERING_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because serverless tasks use Snowflake-managed compute, tracked in
      SERVERLESS_TASK_HISTORY and the METERING_HISTORY view with SERVICE_TYPE = 'TASKS'.
      A is wrong because resource monitors only work with user-managed warehouses.
      C is wrong because they can be monitored. D tracks user-managed warehouses only.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "289"
    question: "Which QUERY_HISTORY column shows the type of SQL statement executed?"
    their_options:
      option A: "SQL_TYPE"
      option B: "QUERY_TYPE"
      option C: "STATEMENT_TYPE"
      option D: "COMMAND_TYPE"
    correct Answer: "B"
    explanation: >
      B is correct because QUERY_TYPE shows the type of SQL statement (SELECT, INSERT,
      CREATE_TABLE, COPY, etc.). A, C, and D are not actual column names in QUERY_HISTORY.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "290"
    question: "What is a common gotcha when monitoring multi-cluster warehouse credit consumption?"
    their_options:
      option A: "Credits are divided equally among all clusters"
      option B: "Each active cluster consumes the full warehouse-size credit rate independently, so 3 active clusters of a Large warehouse consume 24 credits/hour, not 8"
      option C: "Only the primary cluster consumes credits"
      option D: "Multi-cluster warehouses have a flat rate regardless of active clusters"
    correct Answer: "B"
    explanation: >
      B is correct and is a common misconception. Each cluster in a multi-cluster warehouse
      consumes the full credit rate for the warehouse size. A Large warehouse = 8 credits/hour
      per cluster. 3 clusters = 24 credits/hour. People often underestimate multi-cluster
      costs. A is wrong. C is wrong. D is wrong.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "291"
    question: "Which monitoring tool is best for tracking credit usage in near real-time for the current billing period?"
    their_options:
      option A: "ACCOUNT_USAGE.WAREHOUSE_METERING_HISTORY (up to 3-hour latency)"
      option B: "TABLE(INFORMATION_SCHEMA.WAREHOUSE_METERING_HISTORY()) (minimal latency)"
      option C: "SHOW RESOURCE MONITORS (shows current credit usage)"
      option D: "Both B and C provide near real-time data"
    correct Answer: "D"
    explanation: >
      D is correct because both the INFORMATION_SCHEMA table function (B, minimal latency)
      and SHOW RESOURCE MONITORS (C, shows current usage against quota) provide near
      real-time credit tracking. A has up to 3-hour latency, making it unsuitable for
      real-time monitoring.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "292"
    question: "What column in QUERY_HISTORY shows which role executed the query?"
    their_options:
      option A: "ROLE_NAME"
      option B: "EXECUTING_ROLE"
      option C: "USER_ROLE"
      option D: "ROLE"
    correct Answer: "A"
    explanation: >
      A is correct because ROLE_NAME in QUERY_HISTORY shows the active role that was used
      to execute the query. B, C, and D are not the correct column names.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "293"
    question: "How does warehouse monitoring differ between On-Demand and Pre-Purchased (Capacity) pricing?"
    their_options:
      option A: "Monitoring views are different for each pricing model"
      option B: "The monitoring data is identical; the difference is only in how credits translate to dollars"
      option C: "Pre-purchased accounts cannot use resource monitors"
      option D: "On-demand accounts have more monitoring features"
    correct Answer: "B"
    explanation: >
      B is correct. The monitoring views and credit tracking are identical regardless of
      pricing model. The only difference is the dollar cost per credit: on-demand is a
      higher per-credit rate, while pre-purchased (capacity) offers a lower per-credit
      rate with upfront commitment. A, C, and D are incorrect.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, Architect

  - Question No: "294"
    question: "What action should you take if WAREHOUSE_LOAD_HISTORY shows AVG_BLOCKED is consistently high?"
    their_options:
      option A: "Increase warehouse size"
      option B: "Investigate and resolve transaction lock contention (e.g., long-running DML operations blocking other queries)"
      option C: "Add more clusters"
      option D: "Increase AUTO_SUSPEND time"
    correct Answer: "B"
    explanation: >
      B is correct because AVG_BLOCKED indicates queries waiting due to transaction locks
      (concurrent DML on the same tables). The solution is to investigate and resolve lock
      contention, not scale the warehouse. A does not help with locks. C does not help with
      locks. D is unrelated to lock contention.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "295"
    question: "What is the significance of monitoring BYTES_SENT_OVER_THE_NETWORK in QUERY_HISTORY?"
    their_options:
      option A: "It shows data transferred between warehouses"
      option B: "It shows the result set size sent to the client, which impacts network costs and client-side performance"
      option C: "It shows data transferred to external stages"
      option D: "It is not an actual column in QUERY_HISTORY"
    correct Answer: "B"
    explanation: >
      B is correct because BYTES_SENT_OVER_THE_NETWORK indicates the size of results sent
      to the client application. Large values suggest queries returning excessive data,
      which can impact network transfer and client processing. A is wrong. C is wrong.
      D is wrong because this column does exist.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "296"
    question: "Which query finds warehouses with AUTO_SUSPEND disabled?"
    their_options:
      option A: >
        SELECT "name", "auto_suspend" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
        WHERE "auto_suspend" = 0 OR "auto_suspend" IS NULL;
        -- (After running SHOW WAREHOUSES)
      option B: "SHOW WAREHOUSES WHERE AUTO_SUSPEND = 'DISABLED';"
      option C: "SELECT * FROM DISABLED_WAREHOUSES;"
      option D: "DESCRIBE WAREHOUSES AUTO_SUSPEND;"
    correct Answer: "A"
    explanation: >
      A is correct. After running SHOW WAREHOUSES, you can use RESULT_SCAN to filter for
      warehouses where auto_suspend is 0 or NULL (disabled). B is not valid syntax for SHOW
      commands. C and D are not valid.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "297"
    question: "What is the recommended monitoring frequency for warehouse credit consumption in a cost-conscious organization?"
    their_options:
      option A: "Annually during budget reviews"
      option B: "Daily or weekly reviews of credit trends, with real-time alerts via resource monitors for anomalies"
      option C: "Only when the bill seems high"
      option D: "Monthly reviews are sufficient"
    correct Answer: "B"
    explanation: >
      B is correct because cost-conscious organizations should monitor credit trends daily or
      weekly using ACCOUNT_USAGE views and set up resource monitors for real-time alerts on
      anomalies. A and C are too reactive. D may miss short-term spikes.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, Architect

  - Question No: "298"
    question: "A data pipeline team doubled their data volume. What monitoring metrics should they track to ensure warehouse performance remains acceptable? (Select TWO)"
    their_options:
      option A: "EXECUTION_TIME trends for pipeline queries"
      option B: "BYTES_SPILLED_TO_LOCAL_STORAGE and BYTES_SPILLED_TO_REMOTE_STORAGE"
      option C: "LOGIN_HISTORY for the pipeline service account"
      option D: "WAREHOUSE_TYPE changes"
      option E: "Number of databases in the account"
    correct Answer: "A, B"
    explanation: >
      A and B are correct. With doubled data volume, monitoring EXECUTION_TIME (A) reveals
      if queries are slowing down, and spillage metrics (B) show if the warehouse now lacks
      sufficient memory for the larger workload. C is irrelevant. D is unrelated. E does
      not impact warehouse performance monitoring.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "299"
    question: "What happens to resource monitor credit tracking at the end of a MONTHLY period?"
    their_options:
      option A: "Credits roll over to the next period"
      option B: "The credit counter resets to zero for the new period; unused credits are lost"
      option C: "The resource monitor must be manually reset"
      option D: "Credits accumulate across periods"
    correct Answer: "B"
    explanation: >
      B is correct. At the end of each frequency period (e.g., monthly), the credit usage
      counter automatically resets to zero. Any unused credits from the previous period are
      not carried forward. A is wrong because credits do not roll over. C is wrong because
      the reset is automatic. D is wrong because credits do not accumulate.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, Architect

  - Question No: "300"
    question: "Which feature allows you to create a custom dashboard for warehouse monitoring using SQL?"
    their_options:
      option A: "Snowsight Dashboards where you can create tiles with SQL queries against monitoring views"
      option B: "SHOW DASHBOARDS command"
      option C: "CREATE DASHBOARD command"
      option D: "Snowflake does not support custom dashboards"
    correct Answer: "A"
    explanation: >
      A is correct because Snowsight allows creating dashboards with multiple tiles, each
      powered by a SQL query. You can query WAREHOUSE_METERING_HISTORY, QUERY_HISTORY,
      WAREHOUSE_LOAD_HISTORY, and other views to create custom monitoring dashboards.
      B and C are not valid commands. D is wrong.
    difficulty level: Easy
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer, DataAnalyst

  - Question No: "301"
    question: "A warehouse has QUERY_ACCELERATION enabled with MAX_SCALE_FACTOR = 5. What does this mean for monitoring?"
    their_options:
      option A: "The warehouse can use up to 5x its normal credit rate for QAS"
      option B: "QAS can use up to 5 times the warehouse compute resources, meaning additional QAS credits up to 5x the warehouse hourly rate"
      option C: "5 additional clusters are added"
      option D: "Query speed is improved by exactly 5x"
    correct Answer: "B"
    explanation: >
      B is correct. QUERY_ACCELERATION_MAX_SCALE_FACTOR = 5 means QAS can consume up to 5
      times the warehouse's hourly credit rate in additional serverless compute. For an XL
      warehouse (16 credits/hour), QAS could add up to 80 credits/hour. This is important
      for cost monitoring. A is close but less precise. C is wrong. D is wrong because the
      improvement is not guaranteed to be exactly 5x.
    difficulty level: Hard
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: DataEngineer, Architect

  - Question No: "302"
    question: "Which system function can be used to check the status of a warehouse?"
    their_options:
      option A: "SYSTEM$WAREHOUSE_STATUS('MY_WH')"
      option B: "SYSTEM$GET_WAREHOUSE_STATE('MY_WH')"
      option C: "There is no system function; use SHOW WAREHOUSES"
      option D: "SYSTEM$CHECK_WAREHOUSE('MY_WH')"
    correct Answer: "C"
    explanation: >
      C is correct. There is no SYSTEM$ function specifically for checking warehouse status.
      The standard approach is SHOW WAREHOUSES LIKE 'MY_WH' to check the state column.
      A, B, and D reference non-existent system functions.
    difficulty level: Medium
    topic: "Virtual Warehouses"
    sub topic: "Warehouse Monitoring"
    exam: Core, DataEngineer

  - Question No: "303"
    question: "What is the relationship between warehouse SIZE and number of servers (nodes) per cluster?"
    their_options:
      option A: "Each size increase doubles the number of servers: X-Small=1, Small=2, Medium=4, Large=8, etc."
      option B: "All sizes have the same number of servers but different CPU speeds"
      option C: "Server count is random and varies"
      option D: "Server count is fixed at 1 for all sizes"
    correct Answer: 




